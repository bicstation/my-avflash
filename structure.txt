

--- FILE: ./.htaccess ---

# ----------------------------------------------------
# サーバー提供の初期設定 (キャッシュ有効化の制御)
# ----------------------------------------------------
# ----------------------------------------------------
# 【重要】自作MVCモデルの動作保証のための追記設定
# 
# 動的コンテンツ (index.phpが処理するすべて) の
# サーバー側キャッシュを明示的に無効化します。
# これがないと、ユーザー間で情報が混ざる可能性があります。
# ----------------------------------------------------
# ----------------------------------------------------
# 自作MVCモデルのためのリライト設定 (フロントコントローラー)
# ----------------------------------------------------
<IfModule mod_rewrite.c>
    RewriteEngine On
    
    # ★★★ 追加: URIが空 (ルート / ) のアクセスを index.php に渡すことを保証 ★★★
    RewriteRule ^$ index.php [L]
    
    # 既存のファイルやディレクトリへのアクセスはそのまま通す
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    
    # それ以外のすべてのリクエストを index.php に渡す
    RewriteRule ^(.*)$ index.php [L]
</IfModule>
SetEnvIf Request_URI ".*" Ngx_Cache_NoCacheMode

--- FILE: ./vendor/composer/installed.php ---

<?php return array(
    'root' => array(
        'name' => 'avflash/avflash-mvc',
        'pretty_version' => '1.0.0+no-version-set',
        'version' => '1.0.0.0',
        'reference' => NULL,
        'type' => 'library',
        'install_path' => __DIR__ . '/../../',
        'aliases' => array(),
        'dev' => true,
    ),
    'versions' => array(
        'avflash/avflash-mvc' => array(
            'pretty_version' => '1.0.0+no-version-set',
            'version' => '1.0.0.0',
            'reference' => NULL,
            'type' => 'library',
            'install_path' => __DIR__ . '/../../',
            'aliases' => array(),
            'dev_requirement' => false,
        ),
    ),
);


--- FILE: ./vendor/composer/InstalledVersions.php ---

<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer;

use Composer\Autoload\ClassLoader;
use Composer\Semver\VersionParser;

/**
 * This class is copied in every Composer installed project and available to all
 *
 * See also https://getcomposer.org/doc/07-runtime.md#installed-versions
 *
 * To require its presence, you can require `composer-runtime-api ^2.0`
 *
 * @final
 */
class InstalledVersions
{
    /**
     * @var mixed[]|null
     * @psalm-var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}|array{}|null
     */
    private static $installed;

    /**
     * @var bool|null
     */
    private static $canGetVendors;

    /**
     * @var array[]
     * @psalm-var array<string, array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static $installedByVendor = array();

    /**
     * Returns a list of all package names which are present, either by being installed, replaced or provided
     *
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackages()
    {
        $packages = array();
        foreach (self::getInstalled() as $installed) {
            $packages[] = array_keys($installed['versions']);
        }

        if (1 === \count($packages)) {
            return $packages[0];
        }

        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));
    }

    /**
     * Returns a list of all package names with a specific type e.g. 'library'
     *
     * @param  string   $type
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackagesByType($type)
    {
        $packagesByType = array();

        foreach (self::getInstalled() as $installed) {
            foreach ($installed['versions'] as $name => $package) {
                if (isset($package['type']) && $package['type'] === $type) {
                    $packagesByType[] = $name;
                }
            }
        }

        return $packagesByType;
    }

    /**
     * Checks whether the given package is installed
     *
     * This also returns true if the package name is provided or replaced by another package
     *
     * @param  string $packageName
     * @param  bool   $includeDevRequirements
     * @return bool
     */
    public static function isInstalled($packageName, $includeDevRequirements = true)
    {
        foreach (self::getInstalled() as $installed) {
            if (isset($installed['versions'][$packageName])) {
                return $includeDevRequirements || !isset($installed['versions'][$packageName]['dev_requirement']) || $installed['versions'][$packageName]['dev_requirement'] === false;
            }
        }

        return false;
    }

    /**
     * Checks whether the given package satisfies a version constraint
     *
     * e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:
     *
     *   Composer\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')
     *
     * @param  VersionParser $parser      Install composer/semver to have access to this class and functionality
     * @param  string        $packageName
     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package
     * @return bool
     */
    public static function satisfies(VersionParser $parser, $packageName, $constraint)
    {
        $constraint = $parser->parseConstraints((string) $constraint);
        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));

        return $provided->matches($constraint);
    }

    /**
     * Returns a version constraint representing all the range(s) which are installed for a given package
     *
     * It is easier to use this via isInstalled() with the $constraint argument if you need to check
     * whether a given version of a package is installed, and not just whether it exists
     *
     * @param  string $packageName
     * @return string Version constraint usable with composer/semver
     */
    public static function getVersionRanges($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            $ranges = array();
            if (isset($installed['versions'][$packageName]['pretty_version'])) {
                $ranges[] = $installed['versions'][$packageName]['pretty_version'];
            }
            if (array_key_exists('aliases', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);
            }
            if (array_key_exists('replaced', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);
            }
            if (array_key_exists('provided', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);
            }

            return implode(' || ', $ranges);
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getPrettyVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['pretty_version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['pretty_version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference
     */
    public static function getReference($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['reference'])) {
                return null;
            }

            return $installed['versions'][$packageName]['reference'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.
     */
    public static function getInstallPath($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @return array
     * @psalm-return array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}
     */
    public static function getRootPackage()
    {
        $installed = self::getInstalled();

        return $installed[0]['root'];
    }

    /**
     * Returns the raw installed.php data for custom implementations
     *
     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.
     * @return array[]
     * @psalm-return array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}
     */
    public static function getRawData()
    {
        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C' && is_file(__DIR__ . '/installed.php')) {
                self::$installed = include __DIR__ . '/installed.php';
            } else {
                self::$installed = array();
            }
        }

        return self::$installed;
    }

    /**
     * Returns the raw data of all installed.php which are currently loaded for custom implementations
     *
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    public static function getAllRawData()
    {
        return self::getInstalled();
    }

    /**
     * Lets you reload the static array from another file
     *
     * This is only useful for complex integrations in which a project needs to use
     * this class but then also needs to execute another project's autoloader in process,
     * and wants to ensure both projects have access to their version of installed.php.
     *
     * A typical case would be PHPUnit, where it would need to make sure it reads all
     * the data it needs from this class, then call reload() with
     * `require $CWD/vendor/composer/installed.php` (or similar) as input to make sure
     * the project in which it runs can then also use this class safely, without
     * interference between PHPUnit's dependencies and the project's dependencies.
     *
     * @param  array[] $data A vendor/composer/installed.php data set
     * @return void
     *
     * @psalm-param array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $data
     */
    public static function reload($data)
    {
        self::$installed = $data;
        self::$installedByVendor = array();
    }

    /**
     * @return array[]
     * @psalm-return list<array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>}>
     */
    private static function getInstalled()
    {
        if (null === self::$canGetVendors) {
            self::$canGetVendors = method_exists('Composer\Autoload\ClassLoader', 'getRegisteredLoaders');
        }

        $installed = array();

        if (self::$canGetVendors) {
            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {
                if (isset(self::$installedByVendor[$vendorDir])) {
                    $installed[] = self::$installedByVendor[$vendorDir];
                } elseif (is_file($vendorDir.'/composer/installed.php')) {
                    /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                    $required = require $vendorDir.'/composer/installed.php';
                    $installed[] = self::$installedByVendor[$vendorDir] = $required;
                    if (null === self::$installed && strtr($vendorDir.'/composer', '\\', '/') === strtr(__DIR__, '\\', '/')) {
                        self::$installed = $installed[count($installed) - 1];
                    }
                }
            }
        }

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C' && is_file(__DIR__ . '/installed.php')) {
                /** @var array{root: array{name: string, pretty_version: string, version: string, reference: string|null, type: string, install_path: string, aliases: string[], dev: bool}, versions: array<string, array{pretty_version?: string, version?: string, reference?: string|null, type?: string, install_path?: string, aliases?: string[], dev_requirement: bool, replaced?: string[], provided?: string[]}>} $required */
                $required = require __DIR__ . '/installed.php';
                self::$installed = $required;
            } else {
                self::$installed = array();
            }
        }

        if (self::$installed !== array()) {
            $installed[] = self::$installed;
        }

        return $installed;
    }
}


--- FILE: ./vendor/composer/autoload_namespaces.php ---

<?php

// autoload_namespaces.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
);


--- FILE: ./vendor/composer/autoload_psr4.php ---

<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'App\\' => array($baseDir . '/app'),
);


--- FILE: ./vendor/composer/autoload_classmap.php ---

<?php

// autoload_classmap.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'App\\Controllers\\DataController' => $baseDir . '/app/Controllers/DataController.php',
    'App\\Controllers\\HomeController' => $baseDir . '/app/Controllers/HomeController.php',
    'App\\Controllers\\WorksController' => $baseDir . '/app/Controllers/WorksController.php',
    'App\\Core\\CsvParser' => $baseDir . '/app/Core/CsvParser.php',
    'App\\Core\\Database' => $baseDir . '/app/Core/Database.php',
    'App\\Core\\Router' => $baseDir . '/app/Core/Router.php',
    'App\\Model\\WorksModel' => $baseDir . '/app/Model/WorksModel.php',
    'Composer\\InstalledVersions' => $vendorDir . '/composer/InstalledVersions.php',
);


--- FILE: ./vendor/composer/autoload_static.php ---

<?php

// autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInit33a5c39536fa627ffe54d5aa8dcdc343
{
    public static $prefixLengthsPsr4 = array (
        'A' => 
        array (
            'App\\' => 4,
        ),
    );

    public static $prefixDirsPsr4 = array (
        'App\\' => 
        array (
            0 => __DIR__ . '/../..' . '/app',
        ),
    );

    public static $classMap = array (
        'App\\Controllers\\DataController' => __DIR__ . '/../..' . '/app/Controllers/DataController.php',
        'App\\Controllers\\HomeController' => __DIR__ . '/../..' . '/app/Controllers/HomeController.php',
        'App\\Controllers\\WorksController' => __DIR__ . '/../..' . '/app/Controllers/WorksController.php',
        'App\\Core\\CsvParser' => __DIR__ . '/../..' . '/app/Core/CsvParser.php',
        'App\\Core\\Database' => __DIR__ . '/../..' . '/app/Core/Database.php',
        'App\\Core\\Router' => __DIR__ . '/../..' . '/app/Core/Router.php',
        'App\\Model\\WorksModel' => __DIR__ . '/../..' . '/app/Model/WorksModel.php',
        'Composer\\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php',
    );

    public static function getInitializer(ClassLoader $loader)
    {
        return \Closure::bind(function () use ($loader) {
            $loader->prefixLengthsPsr4 = ComposerStaticInit33a5c39536fa627ffe54d5aa8dcdc343::$prefixLengthsPsr4;
            $loader->prefixDirsPsr4 = ComposerStaticInit33a5c39536fa627ffe54d5aa8dcdc343::$prefixDirsPsr4;
            $loader->classMap = ComposerStaticInit33a5c39536fa627ffe54d5aa8dcdc343::$classMap;

        }, null, ClassLoader::class);
    }
}


--- FILE: ./vendor/composer/autoload_real.php ---

<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit33a5c39536fa627ffe54d5aa8dcdc343
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }

        spl_autoload_register(array('ComposerAutoloaderInit33a5c39536fa627ffe54d5aa8dcdc343', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader(\dirname(__DIR__));
        spl_autoload_unregister(array('ComposerAutoloaderInit33a5c39536fa627ffe54d5aa8dcdc343', 'loadClassLoader'));

        require __DIR__ . '/autoload_static.php';
        call_user_func(\Composer\Autoload\ComposerStaticInit33a5c39536fa627ffe54d5aa8dcdc343::getInitializer($loader));

        $loader->register(true);

        return $loader;
    }
}


--- FILE: ./vendor/composer/ClassLoader.php ---

<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 * @see    https://www.php-fig.org/psr/psr-0/
 * @see    https://www.php-fig.org/psr/psr-4/
 */
class ClassLoader
{
    /** @var \Closure(string):void */
    private static $includeFile;

    /** @var string|null */
    private $vendorDir;

    // PSR-4
    /**
     * @var array<string, array<string, int>>
     */
    private $prefixLengthsPsr4 = array();
    /**
     * @var array<string, list<string>>
     */
    private $prefixDirsPsr4 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr4 = array();

    // PSR-0
    /**
     * List of PSR-0 prefixes
     *
     * Structured as array('F (first letter)' => array('Foo\Bar (full prefix)' => array('path', 'path2')))
     *
     * @var array<string, array<string, list<string>>>
     */
    private $prefixesPsr0 = array();
    /**
     * @var list<string>
     */
    private $fallbackDirsPsr0 = array();

    /** @var bool */
    private $useIncludePath = false;

    /**
     * @var array<string, string>
     */
    private $classMap = array();

    /** @var bool */
    private $classMapAuthoritative = false;

    /**
     * @var array<string, bool>
     */
    private $missingClasses = array();

    /** @var string|null */
    private $apcuPrefix;

    /**
     * @var array<string, self>
     */
    private static $registeredLoaders = array();

    /**
     * @param string|null $vendorDir
     */
    public function __construct($vendorDir = null)
    {
        $this->vendorDir = $vendorDir;
        self::initializeIncludeClosure();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixes()
    {
        if (!empty($this->prefixesPsr0)) {
            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));
        }

        return array();
    }

    /**
     * @return array<string, list<string>>
     */
    public function getPrefixesPsr4()
    {
        return $this->prefixDirsPsr4;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirs()
    {
        return $this->fallbackDirsPsr0;
    }

    /**
     * @return list<string>
     */
    public function getFallbackDirsPsr4()
    {
        return $this->fallbackDirsPsr4;
    }

    /**
     * @return array<string, string> Array of classname => path
     */
    public function getClassMap()
    {
        return $this->classMap;
    }

    /**
     * @param array<string, string> $classMap Class to filename map
     *
     * @return void
     */
    public function addClassMap(array $classMap)
    {
        if ($this->classMap) {
            $this->classMap = array_merge($this->classMap, $classMap);
        } else {
            $this->classMap = $classMap;
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix, either
     * appending or prepending to the ones previously set for this prefix.
     *
     * @param string              $prefix  The prefix
     * @param list<string>|string $paths   The PSR-0 root directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @return void
     */
    public function add($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace, either
     * appending or prepending to the ones previously set for this namespace.
     *
     * @param string              $prefix  The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths   The PSR-4 base directories
     * @param bool                $prepend Whether to prepend the directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function addPsr4($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            // Register directories for the root namespace.
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr4
                );
            } else {
                $this->fallbackDirsPsr4 = array_merge(
                    $this->fallbackDirsPsr4,
                    $paths
                );
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            // Register directories for a new namespace.
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = $paths;
        } elseif ($prepend) {
            // Prepend directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                $paths
            );
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix,
     * replacing any others previously set for this prefix.
     *
     * @param string              $prefix The prefix
     * @param list<string>|string $paths  The PSR-0 base directories
     *
     * @return void
     */
    public function set($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace,
     * replacing any others previously set for this namespace.
     *
     * @param string              $prefix The prefix/namespace, with trailing '\\'
     * @param list<string>|string $paths  The PSR-4 base directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function setPsr4($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    /**
     * Turns on searching the include path for class files.
     *
     * @param bool $useIncludePath
     *
     * @return void
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Turns off searching the prefix and fallback directories for classes
     * that have not been registered with the class map.
     *
     * @param bool $classMapAuthoritative
     *
     * @return void
     */
    public function setClassMapAuthoritative($classMapAuthoritative)
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    /**
     * Should class lookup fail if not found in the current class map?
     *
     * @return bool
     */
    public function isClassMapAuthoritative()
    {
        return $this->classMapAuthoritative;
    }

    /**
     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
     *
     * @param string|null $apcuPrefix
     *
     * @return void
     */
    public function setApcuPrefix($apcuPrefix)
    {
        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;
    }

    /**
     * The APCu prefix in use, or null if APCu caching is not enabled.
     *
     * @return string|null
     */
    public function getApcuPrefix()
    {
        return $this->apcuPrefix;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     *
     * @return void
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);

        if (null === $this->vendorDir) {
            return;
        }

        if ($prepend) {
            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;
        } else {
            unset(self::$registeredLoaders[$this->vendorDir]);
            self::$registeredLoaders[$this->vendorDir] = $this;
        }
    }

    /**
     * Unregisters this instance as an autoloader.
     *
     * @return void
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));

        if (null !== $this->vendorDir) {
            unset(self::$registeredLoaders[$this->vendorDir]);
        }
    }

    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return true|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            $includeFile = self::$includeFile;
            $includeFile($file);

            return true;
        }

        return null;
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }

    /**
     * Returns the currently registered loaders keyed by their corresponding vendor directories.
     *
     * @return array<string, self>
     */
    public static function getRegisteredLoaders()
    {
        return self::$registeredLoaders;
    }

    /**
     * @param  string       $class
     * @param  string       $ext
     * @return string|false
     */
    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                $subPath = substr($subPath, 0, $lastPos);
                $search = $subPath . '\\';
                if (isset($this->prefixDirsPsr4[$search])) {
                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        if (file_exists($file = $dir . $pathEnd)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }

    /**
     * @return void
     */
    private static function initializeIncludeClosure()
    {
        if (self::$includeFile !== null) {
            return;
        }

        /**
         * Scope isolated include.
         *
         * Prevents access to $this/self from included files.
         *
         * @param  string $file
         * @return void
         */
        self::$includeFile = \Closure::bind(static function($file) {
            include $file;
        }, null, null);
    }
}


--- FILE: ./vendor/autoload.php ---

<?php

// autoload.php @generated by Composer

if (PHP_VERSION_ID < 50600) {
    if (!headers_sent()) {
        header('HTTP/1.1 500 Internal Server Error');
    }
    $err = 'Composer 2.3.0 dropped support for autoloading on PHP <5.6 and you are running '.PHP_VERSION.', please upgrade PHP or use Composer 2.2 LTS via "composer self-update --2.2". Aborting.'.PHP_EOL;
    if (!ini_get('display_errors')) {
        if (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg') {
            fwrite(STDERR, $err);
        } elseif (!headers_sent()) {
            echo $err;
        }
    }
    trigger_error(
        $err,
        E_USER_ERROR
    );
}

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit33a5c39536fa627ffe54d5aa8dcdc343::getLoader();


--- FILE: ./web.php ---

<?php
// ===============================================
// ルーティング定義リスト (web.php)
// ===============================================

/**
 * @var \App\Core\Router $router $router変数はindex.phpで定義されています
 */

// 1. トップページ / サイトトップ
$router->get('/', 'HomeController@index');          // 引数なし -> index('all')
$router->get('/{siteId}', 'HomeController@index'); // 'lemon' など -> index('lemon')

// 2. 個別作品ページ
$router->get('/work/{workId}', 'WorkController@show');


// ==========================================================
// 3. カテゴリ別作品一覧のルーティング
// ==========================================================

// ★ 全サイト共通ルート (URL例: /tag/ビキニ)
$router->get('/tag/{tagName}', 'TagController@index');
$router->get('/series/{seriesName}', 'SeriesController@index');
$router->get('/actor/{actorName}', 'ActorController@index');
// ★ 新規追加: メーカー
$router->get('/manufacturer/{manufacturerName}', 'ManufacturerController@index');
// ★ 新規追加: レーベル
$router->get('/label/{labelName}', 'LabelController@index');


// ★ 特定サイトルート (URL例: /lemon/tag/ビキニ)
$router->get('/{siteId}/tag/{tagName}', 'TagController@index');
$router->get('/{siteId}/series/{seriesName}', 'SeriesController@index');
$router->get('/{siteId}/actor/{actorName}', 'ActorController@index');
// ★ 新規追加: メーカー
$router->get('/{siteId}/manufacturer/{manufacturerName}', 'ManufacturerController@index');
// ★ 新規追加: レーベル
$router->get('/{siteId}/label/{labelName}', 'LabelController@index');

--- FILE: ./config.php ---

<?php
// ===============================================
// 設定ファイル (config.php)
// ===============================================

// Composer Autoloadを読み込む
require __DIR__ . '/vendor/autoload.php';

// CSVファイルパス定義
$csv_files = [
    'lemon' => __DIR__ . '/data/lemon.csv',
    'okashi' => __DIR__ . '/data/okashi.csv',
    'b10f' => __DIR__ . '/data/b10f.csv',
];

// ★ 修正: APP_NAME 定数ではなく、配列 'app' 内で管理する
// if (!defined('APP_NAME')) {
//     define('APP_NAME', 'AV Flash Site'); 
// }
// print_r($csv_files);

return [
    // アプリケーション設定
    'app' => [
        'base_url' => '/',
        'name' => 'AVFLASH.XYZ', // サイト名はこちらで管理
        'debug' => true, // true: 開発環境 / false: 本番環境
    ],
    
    // データベース設定
    'database' => [
        'driver' => 'mysql', 
        'host' => 'localhost', 
        'dbname' => 'wp552476_avflash', 
        'username' => 'wp552476_avflash', 
        'password' => '1492nabe', 
        'charset' => 'utf8mb4',
        // 'collation' => 'utf8mb4_unicode_ci',
    ],
    
    // データ設定 (CSVファイルパスなど)
    'data' => [
        'csv_files' => $csv_files,
    ],
    
    // ★ ページネーション設定 (TagControllerで使用)
    'pagination' => [
        // 作品一覧で1ページあたりに表示する件数
        'works_per_page' => 20, 
    ],
];

--- FILE: ./app/helpers.php ---

<?php
// ===============================================
// グローバルヘルパー関数 (app/helpers.php)
// ===============================================

// グローバルで設定配列を保持 (config.phpで require_once される際に初期化される)
global $config;

/**
 * 設定値を取得する (Laravel風 config() 関数)
 * @param string $key (例: 'app.name', 'data.csv_files')
 * @return mixed
 */
function config(string $key): mixed {
    global $config;
    $keys = explode('.', $key);
    $value = $config;

    foreach ($keys as $k) {
        if (!is_array($value) || !isset($value[$k])) {
            return null;
        }
        $value = $value[$k];
    }
    return $value;
}

// ===============================================
// ビュー・テンプレート関数 (修正済み)
// ===============================================

// ===============================================
// ビュー・テンプレート関数 (修正版)
// ===============================================

/**
 * ビューをレンダリングする (コンテンツをバッファリングし、レイアウトに渡す)
 * @param string $viewPath (例: 'works.index' -> views/works/index.php)
 * @param array $data ビューに渡すデータ
 */
function view(string $viewPath, array $data = []): void {
    
    // ドット記法をパスに変換
    $contentPath = str_replace('.', '/', $viewPath); 
    
    // アプリケーションのルートディレクトリを取得 (index.phpがある場所を基準)
    // index.php から helpers.php が require されているなら、ROOT_PATH は index.php のディレクトリ
    // ただし、最も安全な方法は、ビューディレクトリまでの絶対パスを取得することです。
    
    // **重要な修正:** どこから呼び出されても、絶対パスでビューディレクトリを指定
    // ここでは、public_html/views/ をルートと仮定
    $viewDir = dirname(__DIR__) . '/views/'; // /public_html/views/ を指す
    
    // データを現在のスコープに展開
    extract($data, EXTR_OVERWRITE); 
    
    // ----------------------------------------------------------------
    // 1. メインコンテンツのバッファリング
    // ----------------------------------------------------------------
    ob_start();
    
    $fullContentPath = $viewDir . $contentPath . '.php'; // ★ 絶対パスで結合

    if (!file_exists($fullContentPath)) {
        // ビューファイルが存在しない場合はエラーを表示し、デバッグを助ける
        ob_end_clean(); // バッファを破棄
        http_response_code(500);
        dd("View file not found: " . $fullContentPath);
    }
    
    require $fullContentPath; 
    $content = ob_get_clean();
    
    // ----------------------------------------------------------------
    // 2. レイアウトへの引き渡しとレンダリング
    // ----------------------------------------------------------------
    extract(['content' => $content], EXTR_OVERWRITE);

    // レイアウトファイルも絶対パスで指定
    $layoutPath = $viewDir . 'layouts/app.php'; // ★ 絶対パスで結合
    
    if (!file_exists($layoutPath)) {
        http_response_code(500);
        dd("Layout file not found: " . $layoutPath);
    }

    require $layoutPath; 
}

/**
 * 特定のビューパーツ（テンプレートの一部）を読み込む
 * この関数は、コンテンツがバッファリングされるようになったため、不要になります。
 */
function get_template_part(string $partPath): void {
    // 実行されなくなります
    require __DIR__ . '/../views/' . $partPath . '.php';
}


// ===============================================
// デバッグ関数
// ===============================================

/**
 * 変数の内容を整形して表示し、処理を終了する (Dump and Die)
 */
function dd($var): void {
    echo "<pre style='background: #333; color: #fff; padding: 15px; border: 1px solid #000; z-index: 9999; font-size: 14px;'>";
    var_dump($var);
    echo "</pre>";
    exit;
}

/**
 * 変数の内容を整形して表示する (Dump)
 */
function dump($var): void {
    echo "<pre style='background: #f0f0f0; color: #000; padding: 10px; border: 1px solid #ccc; z-index: 9998; font-size: 12px;'>";
    var_dump($var);
    echo "</pre>";
}



--- FILE: ./app/Core/Router.php ---

<?php
namespace App\Core;

class Router
{
    protected static array $routes = [];

    public function get(string $uri, string $controllerAction): void
    {
        self::addRoute('GET', $uri, $controllerAction);
    }
    
    // ... post() メソッドなど ...

    protected static function addRoute(string $method, string $uri, string $controllerAction): void
    {
        // Controller@method を [ControllerName, methodName] に分割
        list($controller, $action) = explode('@', $controllerAction);
        self::$routes[$method][$uri] = [$controller, $action]; 
    }

    /**
     * URIから対応するコントローラー、メソッド、および引数を検索する
     * @param string $uri 現在のリクエストURI
     * @return array|null [Controller名, Method名, [引数値]] または null
     */
    public static function findRoute(string $uri): ?array
    {
        $method = strtoupper($_SERVER['REQUEST_METHOD']);
        $path = strtok($uri, '?');
        $path = rtrim($path, '/');
        if ($path === '') {
            $path = '/'; 
        }

        if (!isset(self::$routes[$method])) {
            return null;
        }

        $definedRoutes = self::$routes[$method];

        foreach ($definedRoutes as $routeUri => $routeInfo) {
            
            // 1. 完全一致チェック
            if ($routeUri === $path) {
                
                $args = [];
                if ($path === '/') {
                    // トップページ ('/') のデフォルトサイトIDを 'okashi' に設定
                    $args = ['okashi']; 
                }
                
                return [$routeInfo[0], $routeInfo[1], $args];
            }
            
            // 2. 可変セグメントチェック
            if (strpos($routeUri, '{') !== false) {
                
                $routeSegments = explode('/', trim($routeUri, '/'));
                $pathSegments = explode('/', trim($path, '/'));
                
                if (count($routeSegments) !== count($pathSegments)) {
                    continue;
                }

                $args = [];
                $match = true;

                for ($i = 0; $i < count($routeSegments); $i++) {
                    $routeSegment = $routeSegments[$i];
                    $pathSegment = $pathSegments[$i];

                    // セグメントがプレースホルダーの場合
                    if (preg_match('/^\{([a-zA-Z0-9]+)\}$/', $routeSegment, $matches)) {
                        $args[] = $pathSegment; 
                    } 
                    // セグメントが固定文字列で、一致しない場合
                    elseif ($routeSegment !== $pathSegment) {
                        $match = false;
                        break;
                    }
                }

                if ($match) {
                    return [$routeInfo[0], $routeInfo[1], $args];
                }
            }
        }
        
        return null;
    }
}

--- FILE: ./app/Core/Database.php ---

<?php

namespace App\Core;

use PDO;
use PDOException;

class Database
{
    private static ?PDO $pdoInstance = null;
    private static array $config = [];

    /**
     * config.phpから設定を読み込む
     */
    public static function loadConfig(array $config): void
    {
        self::$config = $config['database'];
    }

    /**
     * PDOインスタンスを取得する（シングルトンパターン）
     */
    public static function getConnection(): PDO
    {
        if (self::$pdoInstance === null) {
            $c = self::$config;
            
            // configからcharsetを読み込む: 'charset=utf8mb4'
            $dsn = "{$c['driver']}:host={$c['host']};dbname={$c['dbname']};charset={$c['charset']}";

            try {
                // ★★★ 修正箇所: 接続オプションにPDO::MYSQL_ATTR_INIT_COMMANDを追加 ★★★
                $options = [
                    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                    PDO::ATTR_EMULATE_PREPARES => false,
                    // MySQL接続直後に、クライアント側の文字セットと照合順序を統一するコマンドを強制実行
                    // エラーメッセージで混在が指摘されている照合順序の片方（ここではutf8mb4_unicode_ci）に統一します。
                    PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci"
                ];

                self::$pdoInstance = new PDO($dsn, $c['username'], $c['password'], $options);
            } catch (PDOException $e) {
                // データベース接続エラーは致命的なので、詳細をログに残すべき
                die("Database connection error: " . $e->getMessage());
            }
        }
        return self::$pdoInstance;
    }


    /**
     * クエリ実行ヘルパー
     * ... (以下、queryメソッドは変更なし)
     */
    public static function query(string $sql, array $params = []): array|bool
    {
        $pdo = self::getConnection();
        $stmt = $pdo->prepare($sql);

        // 実行が成功したかどうかをチェック
        if (!$stmt->execute($params)) {
            // PDO::ERRMODE_EXCEPTIONを設定しているため、ここには通常到達しませんが、念のため
            return false;
        }

        // SELECT文の場合は結果を返す
        if (strtoupper(substr(trim($sql), 0, 6)) === 'SELECT') {
            return $stmt->fetchAll(); // 返り値の型は array
        }

        // INSERT/UPDATE/DELETEなどの場合は成功を返す
        return true; // 返り値の型は bool (これで赤線が消えます)
    }
}

--- FILE: ./app/Core/CsvParser.php ---

<?php
namespace App\Core;

class CsvParser
{
    /**
     * CSVファイルからデータを読み込み、連想配列の配列として返す
     * * @param string $filePath 読み込むCSVファイルの絶対パス
     * @param string $delimiter 区切り文字 (通常はカンマ ',')
     * @return array CSVデータの連想配列の配列
     * @throws \Exception ファイルが見つからない、または読み込めない場合
     */
    public static function parse(string $filePath, string $delimiter = ','): array
    {
        if (!file_exists($filePath) || !is_readable($filePath)) {
            throw new \Exception("CSV file not found or unreadable: " . $filePath);
        }

        $data = [];
        // ファイルポインタを開く
        if (($handle = fopen($filePath, 'r')) !== false) {
            
            // 1. ヘッダー行を読み込む
            $headers = fgetcsv($handle, 0, $delimiter); // 0は最大行長なし
            if ($headers === false) {
                fclose($handle);
                return $data;
            }
            
            // ヘッダーのクリーンアップ: 空白・全角スペースのトリム
            // CSVヘッダーの「木下凛々子  お綺麗ですね隣の奥様 凛々子奥様編」のような全角スペースを処理するため、mb_convert_kanaを使用します
            $headers = array_map(function($h) {
                // 全角スペースを半角に変換し、両端の空白をトリム
                $cleaned = trim(mb_convert_kana($h, 's'));
                // CSV内の不必要なダブルクォートやNULL文字も取り除く
                return str_replace(['"', "\0"], '', $cleaned); 
            }, $headers);

            // 2. データ行を読み込む
            while (($row = fgetcsv($handle, 0, $delimiter)) !== false) {
                // 行データにもクリーンアップを適用 (特にHTMLリンクの末尾などに含まれる余計な空白を処理)
                $row = array_map('trim', $row);

                // ヘッダー数とカラム数が一致しない行はスキップ（CSVの破損対策）
                if (count($headers) !== count($row)) {
                    // エラーログに出力し、処理を続行
                    error_log("Row skipped due to mismatched column count in CSV: " . $filePath);
                    continue; 
                }
                
                // ヘッダーと行データを結合して連想配列を作成
                $data[] = array_combine($headers, $row);
            }
            
            fclose($handle);
        }

        return $data;
    }
}

--- FILE: ./app/Core/Config.php ---

<?php

namespace App\Core;

/**
 * 設定値へのアクセスを提供する静的ユーティリティクラス
 */
class Config
{
    /**
     * @var array アプリケーション全体の設定を保持する配列
     */
    private static array $settings = [];

    /**
     * config.php ファイルから設定を読み込み、静的プロパティに格納する
     *
     * @param array $config config.phpが返す連想配列
     */
    public static function load(array $config): void
    {
        self::$settings = $config;
    }

    /**
     * 設定キーを指定して値を取得する
     * ネストされたキーはドット記法 (例: 'database.dbname') でアクセス可能
     *
     * @param string $key 取得したい設定キー
     * @param mixed $default キーが存在しない場合に返すデフォルト値
     * @return mixed 設定値、またはデフォルト値
     */
    public static function get(string $key, $default = null)
    {
        $keys = explode('.', $key);
        $value = self::$settings;

        foreach ($keys as $k) {
            if (is_array($value) && array_key_exists($k, $value)) {
                $value = $value[$k];
            } else {
                return $default; // キーが見つからなかった場合はデフォルト値を返す
            }
        }

        return $value;
    }
}

--- FILE: ./app/Controllers/DataController.php ---

<?php

namespace App\Controllers;

use App\Core\Database;
use App\Models\WorksModel;

class DataController
{
    private WorksModel $worksModel;

    /**
     * CSVのカラム名マッピング。サイトIDに応じて異なるCSVヘッダーに対応する。
     */
    private const CSV_COLUMN_MAP = [
        // OKASHI の長いカラム名
        'okashi' => [
            'cover_url'           => '広告用画像URL(他に1.jpg[ジャケット表大]、2.jpg[ジャケット裏大]、c1.jpgからcキャプチャ画像数.jpg[キャプチャ画像]も利用できます)',
            'jacket_link'         => 'どれでもバナー ジャケット表(小)型',
            'player_html'         => 'どれでもバナー プレーヤ型(iframe)型',
            'brand_link'          => 'どれでもバナー メーカ作品一覧',
            'label_link'          => 'どれでもバナー レーベル作品一覧', // レーベルのリンク
            'series_link'         => 'どれでもバナー シリーズ作品一覧', // シリーズのリンク
            'raw_manufacturer_name' => 'ブランド', // 生のメーカー名カラム (実質ブランド名)
            'raw_series_name'     => 'シリーズ',
        ],
        // LEMON の短縮されたカラム名
        'lemon' => [
            // ★ 作品情報
            'cover_url'           => '広告用ジャケットURL',
            'jacket_link'         => 'どれでもバナー ジャケット型',
            'player_html'         => 'どれでもバナー プレーヤ型(iframe)型',

            // ★ リレーション情報
            'raw_manufacturer_name' => 'ブランド',
            'brand_link'          => 'どれでもバナー メーカ作品一覧',
            'label_link'          => 'どれでもバナー レーベル作品一覧',
            'series_link'         => 'どれでもバナー シリーズ作品一覧',

            // ★ 紐付け情報
            'actor_link'          => 'どれでもバナー 出演作品一覧',
            'tag_link'            => 'どれでもバナー タグ作品一覧',

            // ★ キャプチャ画像 (c1〜c16)
            'capture_1'           => 'どれでもバナー キャプチャ1',
            'capture_2'           => 'どれでもバナー キャプチャ2',
            'capture_3'           => 'どれでもバナー キャプチャ3',
            'capture_4'           => 'どれでもバナー キャプチャ4',
            'capture_5'           => 'どれでもバナー キャプチャ5',
            'capture_6'           => 'どれでもバナー キャプチャ6',
            'capture_7'           => 'どれでもバナー キャプチャ7',
            'capture_8'           => 'どれでもバナー キャプチャ8',
            'capture_9'           => 'どれでもバナー キャプチャ9',
            'capture_10'          => 'どれでもバナー キャプチャ10',
            'capture_11'          => 'どれでもバナー キャプチャ11',
            'capture_12'          => 'どれでもバナー キャプチャ12',
            'capture_13'          => 'どれでもバナー キャプチャ13',
            'capture_14'          => 'どれでもバナー キャプチャ14',
            'capture_15'          => 'どれでもバナー キャプチャ15',
            'capture_16'          => 'どれでもバナー キャプチャ16',
        ],
        // B10F のカラム名
        'b10f' => [
            // ★ 作品情報
            'cover_url'           => '広告用画像URL(他に1.jpg[ジャケット表大]、2.jpg[ジャケット裏大]、c1.jpgからcキャプチャ画像数.jpg[キャプチャ画像]も利用できます)',
            'jacket_link'         => 'どれでもバナー ジャケット表(小)型',
            'player_html'         => 'どれでもバナー プレーヤ型(iframe)型',

            // ★ リレーション情報
            'raw_manufacturer_name' => 'ブランド',
            'brand_link'          => 'どれでもバナー メーカ作品一覧',
            'series_link'         => 'どれでもバナー シリーズ作品一覧',

            // B10Fにはレーベルリンクが存在しないため、空文字列を設定
            'label_link'          => '',

            'actor_link'          => 'どれでもバナー 出演作品一覧',
            'tag_link'            => 'どれでもバナー タグ作品一覧',

            // ★ キャプチャ画像 (c1〜c16)
            'capture_1'           => 'どれでもバナー キャプチャ1',
            'capture_2'           => 'どれでもバナー キャプチャ2',
            'capture_3'           => 'どれでもバナー キャプチャ3',
            'capture_4'           => 'どれでもバナー キャプチャ4',
            'capture_5'           => 'どれでもバナー キャプチャ5',
            'capture_6'           => 'どれでもバナー キャプチャ6',
            'capture_7'           => 'どれでもバナー キャプチャ7',
            'capture_8'           => 'どれでもバナー キャプチャ8',
            'capture_9'           => 'どれでもバナー キャプチャ9',
            'capture_10'          => 'どれでもバナー キャプチャ10',
            'capture_11'          => 'どれでもバナー キャプチャ11',
            'capture_12'          => 'どれでもバナー キャプチャ12',
            'capture_13'          => 'どれでもバナー キャプチャ13',
            'capture_14'          => 'どれでもバナー キャプチャ14',
            'capture_15'          => 'どれでもバナー キャプチャ15',
            'capture_16'          => 'どれでもバナー キャプチャ16',
        ],
    ];

    public function __construct(WorksModel $worksModel)
    {
        $this->worksModel = $worksModel;
    }

    /**
     * CSVファイルを読み込み、データベースにインポートする処理の実行
     * @param string $csvFilePath CSVファイルのパス
     */
    public function importData(string $csvFilePath): void // ★ 変更なし
    {
        // ★ 変更点2: CSVファイルパスからサイトIDを抽出するロジックを追加
        $pathInfo = pathinfo($csvFilePath);
        $siteId = $pathInfo['filename'] ?? ''; // ファイル名（例: 'okashi'）をサイトIDとして使用

        if (!in_array($siteId, ['okashi', 'lemon', 'b10f'])) {
            // siteIdが不正、またはファイル名から特定できなかった場合
            echo "Error: Invalid site ID provided or could not be inferred from file path: " . $csvFilePath . "\n";
            return;
        }

        if (!file_exists($csvFilePath)) {
            echo "Error: CSV file not found at " . $csvFilePath . "\n";
            return;
        }

        // CSVファイルを開く
        $file = fopen($csvFilePath, 'r');
        if ($file === false) {
            echo "Error: Could not open CSV file.\n";
            return;
        }

        // ヘッダーを読み込み
        $headers = fgetcsv($file);
        if ($headers === false) {
            echo "Error: Could not read CSV headers.\n";
            fclose($file);
            return;
        }

        // ヘッダーの整形とマップの取得
        $headers = array_map(function ($h) {
            return trim($h);
        }, $headers);
        $map = self::CSV_COLUMN_MAP[$siteId];
        $worksCount = 0;

        try {
            // トランザクション開始
            Database::getConnection()->beginTransaction();

            while (($row = fgetcsv($file)) !== false) {
                // 行データとヘッダーを組み合わせる (連想配列化)
                if (count($headers) !== count($row)) {
                    // データとヘッダーの列数が一致しない場合はスキップ
                    error_log("Skipping row due to column count mismatch.");
                    continue;
                }
                $rowData = array_combine($headers, $row);

                // マップから生のブランド名カラム名を取得
                $rawBrandNameCol = $map['raw_manufacturer_name'];

                // 基本作品情報の抽出
                $workId         = $rowData['商品ID'] ?? null;
                $releaseDate    = $rowData['配信日'] ?? null;
                $title          = $rowData['タイトル'] ?? null;
                $brandNameRaw   = $rowData[$rawBrandNameCol] ?? null; // ★ マップされたカラム名を使用
                $categoryName   = $rowData['カテゴリー名'] ?? null;
                $price          = (int) ($rowData['レンタル視聴を含む最低価格[税込]'] ?? 0);
                $runtimeMin     = (int) ($rowData['収録時間'] ?? 0);
                $comment        = $rowData['コメント'] ?? null;
                $captureCount   = (int) ($rowData['キャプチャ画像数'] ?? 0);
                $productUrl     = $rowData['商品URL'] ?? null;

                if (empty($workId) || empty($releaseDate) || empty($title) || empty($productUrl)) {
                    continue; // 必須データがなければスキップ
                }

                // サイトごとのヘッダー名を持つ共通データの抽出
                $coverUrlCol = $map['cover_url'];
                $jacketLinkCol = $map['jacket_link'];
                $playerHtmlCol = $map['player_html'];
                $brandLinkCol = $map['brand_link'];

                $coverUrl       = $rowData[$coverUrlCol] ?? null;
                $jacketLinkHtml = $rowData[$jacketLinkCol] ?? null;
                $playerHtml     = $rowData[$playerHtmlCol] ?? null;
                $brandLinkHtml  = $rowData[$brandLinkCol] ?? null;

                // 'どれでもバナー'形式で共通しているヘッダーから抽出
                $actorLinkHtml  = $rowData['どれでもバナー 出演作品一覧'] ?? '';
                $tagLinkHtml    = $rowData['どれでもバナー タグ作品一覧'] ?? '';

                // --- データのクリーニングと抽出 ---

                // 女優名抽出
                $actorName = $this->extractActorNameFromHtml($actorLinkHtml);

                // タグ名抽出
                $tagNames = $this->extractTagsFromHtml($tagLinkHtml);

                // --- worksテーブルへの挿入/更新 ---
                $worksData = [
                    'site_id'       => $siteId,
                    'work_id'       => $workId,
                    'release_date'  => $releaseDate,
                    'title'         => $title,
                    'brand_name'    => $brandNameRaw,
                    'category_name' => $categoryName,
                    'price'         => $price,
                    'runtime_min'   => $runtimeMin,
                    'comment'       => $comment,
                    'capture_count' => $captureCount,
                    'cover_url'     => $coverUrl,
                    'product_url'   => $productUrl,
                    'player_html'   => $playerHtml,
                ];

                $this->worksModel->insertOrUpdateWork($worksData);
                $worksCount++;

                // ★ 追加: 100件ごとの進捗表示ロジック ★
                if ($worksCount % 100 === 0) {
                    echo "Processing record #{$worksCount}...\n";
                }


                // --- 関連テーブルへの挿入/更新 ---

                // 1. アクターの挿入と関連付け (work_actors)
                if (!empty($actorName)) {
                    $actorId = $this->worksModel->insertOrGetActor($actorName, $siteId);
                    $this->worksModel->insertWorkActorLink($workId, $siteId, $actorId);
                }

                // 2. タグの挿入と関連付け (work_tags)
                if (!empty($tagNames)) {
                    $this->worksModel->insertWorkTags($workId, $siteId, $tagNames);
                }

                // 3. ブランドの挿入と関連付け (brands, work_brands) ★修正: manufactures -> brands
                if (!empty($brandNameRaw) && !empty($brandLinkHtml)) {
                    // ✅ 正: brandsテーブルに合わせたメソッド名に変更 (Model側もBrandで実装)
                    $brandId = $this->worksModel->insertOrGetBrand($brandNameRaw, $siteId);

                    if ($brandId > 0) {
                        // ✅ 正: work_brandsテーブルに合わせたメソッド名に変更
                        $this->worksModel->insertWorkBrandLink($workId, $siteId, $brandId, $brandLinkHtml);
                    }
                }

                // 4. レーベルの挿入と関連付け (labels, work_labels)
                $labelLinkHtml = $rowData[$map['label_link']] ?? ''; // B10Fでは空文字列になる
                $labelNameRaw = $this->extractLabelNameFromHtml($labelLinkHtml);

                if (!empty($labelNameRaw) && !empty($labelLinkHtml)) {
                    // Model側でsiteIdを考慮した insertOrGetLabel が必要
                    $labelId = $this->worksModel->insertOrGetLabel($labelNameRaw, $siteId);

                    if ($labelId > 0) {
                        $this->worksModel->insertWorkLabelLink($workId, $siteId, $labelId, $labelLinkHtml);
                    }
                }

                // 5. シリーズの挿入と関連付け (series, work_series)
                $seriesLinkHtml = $rowData[$map['series_link']] ?? '';
                $seriesNameRaw = $this->extractSeriesNameFromHtml($seriesLinkHtml);

                if (!empty($seriesNameRaw) && !empty($seriesLinkHtml)) {
                    $seriesId = $this->worksModel->insertOrGetSeries($seriesNameRaw, $siteId);

                    if ($seriesId > 0) {
                        $this->worksModel->insertWorkSeriesLink($workId, $siteId, $seriesId, $seriesLinkHtml);
                    }
                }

                // 6. キャプチャ画像の挿入 (work_captures)
                $captureLinks = [];
                if ($captureCount > 0) {
                    // マップ定義に沿って最大16件のキャプチャリンクをチェック
                    for ($i = 1; $i <= 16; $i++) {
                        $key = "capture_{$i}";
                        if (!isset($map[$key])) continue;

                        $headerName = $map[$key];
                        $captureLinkHtml = $rowData[$headerName] ?? '';

                        if (!empty($captureLinkHtml)) {
                            // リンクHTMLから画像URLを抽出
                            $imageUrl = '';
                            if (preg_match('/src="([^"]+)"/i', $captureLinkHtml, $matches)) {
                                $imageUrl = $matches[1];
                            }

                            $captureLinks[] = [
                                'capture_number' => $i,
                                'image_url'      => $imageUrl,
                                'link_html'      => $captureLinkHtml,
                            ];
                        }
                    }

                    if (!empty($captureLinks)) {
                        $this->worksModel->insertCaptures($workId, $siteId, $captureLinks);
                    }
                }

                // 7. アフィリエイトリンクの挿入 (work_affiliates)
                $affiliateData = [
                    'link_jacket'       => $rowData['どれでもバナー ジャケット表型'] ?? '',
                    'link_player'       => $rowData['どれでもバナー プレーヤ型(iframe)型'] ?? '',
                    'link_title'        => $rowData['どれでもバナー 作品名リンク'] ?? '',
                    'link_actor_list'   => $rowData['どれでもバナー 出演作品一覧'] ?? '',
                    'link_series_list'  => $rowData['どれでもバナー シリーズ作品一覧'] ?? '',
                ];

                // キャプチャリンクを work_affiliates 用の配列に追加 (最大16件)
                for ($i = 1; $i <= 16; $i++) {
                    $headerKey = "どれでもバナー キャプチャ{$i}";
                    $columnKey = "capture_{$i}_link";

                    if (isset($rowData[$headerKey])) {
                        $affiliateData[$columnKey] = $rowData[$headerKey];
                    }
                }

                // Modelを呼び出して work_affiliates に挿入
                $this->worksModel->insertOrUpdateWorkAffiliates($workId, $siteId, $affiliateData);
            }

            // トランザクションコミット
            Database::getConnection()->commit();

            // ===============================================================
            // ★★★ 診断ロジックの追加 ★★★
            // ===============================================================

            echo "\n--- Import Completed: {$worksCount} records processed ---\n";
            
            // --- 1. 再計算前のカウント表示 ---
            // ※ WorksModel.phpにgetTableCounts()メソッドが実装されている必要があります
            $preRecalculationCounts = $this->worksModel->getTableCounts(); 
            echo "--- Table Counts (Pre-Recalculation) ---\n";
            foreach ($preRecalculationCounts as $table => $count) {
                echo "{$table}: {$count}\n";
            }
            echo "-----------------------------------------\n";

            // カウントの再計算 (このいずれかでエラーが発生している可能性が極めて高い)
            $this->worksModel->recalculateCounts();       // アクター、タグなどの作品数を再計算
            echo "Successfully ran recalculateCounts().\n"; // ★ 診断用: 成功したら表示

            $this->worksModel->recalculateLabelCounts();  // レーベルの作品数を再計算
            echo "Successfully ran recalculateLabelCounts().\n"; // ★ 診断用: 成功したら表示

            $this->worksModel->recalculateBrandCounts();  // ブランドの作品数を再計算
            echo "Successfully ran recalculateBrandCounts().\n"; // ★ 診断用: 成功したら表示

            $this->worksModel->recalculateSeriesCounts(); // シリーズの作品数を再計算
            echo "Successfully ran recalculateSeriesCounts().\n"; // ★ 診断用: 成功したら表示
            
            // --- 2. 再計算後のカウント表示 ---
            $postRecalculationCounts = $this->worksModel->getTableCounts();
            echo "\n--- Table Counts (Post-Recalculation) ---\n";
            foreach ($postRecalculationCounts as $table => $count) {
                echo "{$table}: {$count}\n";
            }
            echo "-------------------------------------------\n";


            echo "Successfully imported {$worksCount} records for {$siteId}.\n";
        } catch (\PDOException $e) {
            // エラーが発生した場合、ロールバック
            if (Database::getConnection()->inTransaction()) {
                 Database::getConnection()->rollBack();
            }
            echo "Database error during import: " . $e->getMessage() . "\n";
        } finally {
            fclose($file);
        }
    }

    // --- データ抽出ヘルパーメソッド ---

    /**
     * CSVのHTML文字列からタグ名を抽出する
     * @param string $tagHtml CSVから読み込んだ「タグ作品一覧」カラムのHTML文字列
     * @return array クリーンなタグ名の配列
     */
    private function extractTagsFromHtml(string $tagHtml): array
    {
        $tags = [];
        // <a>タグのリンクテキストをすべて抽出する
        preg_match_all('/<a[^>]*>(.*?)<\/a>/i', $tagHtml, $matches);

        if (!empty($matches[1])) {
            foreach ($matches[1] as $tagText) {
                // 抽出したテキストから不要な記号や空白を除去する
                $cleanedTag = trim(
                    str_replace(['[', ']'], '', $tagText)
                );

                if (!empty($cleanedTag)) {
                    // タグを「/」で区切って複数ある場合は分割する (例: フルHD対応 / 私服)
                    $splitTags = array_map('trim', explode('/', $cleanedTag));
                    $tags = array_merge($tags, $splitTags);
                }
            }
        }
        // 重複を排除して返す
        return array_unique(array_filter($tags));
    }

    /**
     * CSVのHTML文字列から女優名を抽出する
     * @param string $actorLinkHtml CSVから読み込んだ「出演作品一覧」カラムのHTML文字列
     * @return string クリーンな女優名
     */
    private function extractActorNameFromHtml(string $actorLinkHtml): string
    {
        $actorText = '';
        // 1. <a>タグのリンクテキストを抽出する
        if (preg_match('/<a[^>]*>(.*?)<\/a>/i', $actorLinkHtml, $matches)) {
            $actorText = $matches[1] ?? '';
        }
        // 2. 空白をトリム
        $actorText = trim($actorText);
        // 3. (ローマ字表記など) の部分があれば除去する
        $parenPos = strpos($actorText, '(');
        if ($parenPos !== false) {
            // '(' の前の部分のみを抽出
            $actorText = trim(substr($actorText, 0, $parenPos));
        }
        // 4. 空白でない女優名を返す
        return $actorText;
    }


    /**
     * CSVのHTML文字列からレーベル名を抽出する
     * @param string $labelLinkHtml CSVから読み込んだ「レーベル作品一覧」カラムのHTML文字列
     * @return string クリーンなレーベル名
     */
    private function extractLabelNameFromHtml(string $labelLinkHtml): string
    {
        $labelText = '';
        // 1. <a>タグのリンクテキストを抽出する
        if (preg_match('/<a[^>]*>(.*?)<\\/a>/i', $labelLinkHtml, $matches)) {
            $labelText = $matches[1] ?? '';
        }
        // 2. 抽出したテキストをクリーンアップ
        return trim($labelText);
    }

    /**
     * CSVのHTML文字列からシリーズ名を抽出する
     * @param string $seriesLinkHtml CSVから読み込んだ「シリーズ作品一覧」カラムのHTML文字列
     * @return string クリーンなシリーズ名
     */
    private function extractSeriesNameFromHtml(string $seriesLinkHtml): string
    {
        $seriesText = '';
        // 1. <a>タグのリンクテキストを抽出する
        if (preg_match('/<a[^>]*>(.*?)<\\/a>/i', $seriesLinkHtml, $matches)) {
            $seriesText = $matches[1] ?? '';
        }
        // 2. 抽出したテキストをクリーンアップ
        return trim($seriesText);
    }
}


--- FILE: ./app/Controllers/HomeController.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/controllers/HomeController.php

namespace App\Controllers;

use App\Models\WorksModel;
use App\Controllers\NavController;

class HomeController
{
    /**
     * トップページ (作品一覧) を表示するアクション
     * URL: /{siteId} または / (ルーティングで処理)
     * @param string $siteId 現在閲覧中のサイトID。 デフォルトは 'okashi' を表示する。
     */
    public function index(string $siteId = 'okashi') // ★ 変更1: デフォルトを 'okashi' に変更
    {
        // 1. 初期設定
        $perPage = 30; // 1ページあたりの表示件数
        // GETパラメータからページ番号を取得。未指定の場合は1。
        $page = $_GET['page'] ?? 1;
        $offset = ($page - 1) * $perPage;

        // モデルのインスタンス化
        $worksModel = new WorksModel();
        
        // 2. 作品データの取得 (特定サイトのロジックに統一)
        // ★ 変更2: 'all' の分岐を削除
        
        // 特定サイトの場合（lemon, okashi, b10f, またはデフォルトの okashi）
        $works = $worksModel->getLatestWorks($siteId, $perPage, $offset);
        $totalWorks = $worksModel->getTotalWorksCount($siteId);
        $titlePrefix = strtoupper($siteId);
        // dd($works);
        $totalPages = ceil($totalWorks / $perPage);

        // 3. サイドバーデータの取得とメタ情報の決定
        $navController = new NavController();
        
        // NavControllerは 'all' 処理を削除済みなので、そのまま $siteId を渡す
        $sidebarData = $navController->getSidebarData($siteId); 
        $sidebarMeta = $navController->getSidebarMeta($siteId);

        dd($sidebarData);

        // 4. Viewにデータを渡してレンダリング
        // view() 関数はグローバル関数か、基底コントローラーで定義されているものと仮定
        view('home/index', [
            'title' => $titlePrefix . ' | 最新作品一覧', 
            'currentSiteId' => $siteId, // 統一された変数名
            'works' => $works,
            'currentPage' => $page,
            'totalPages' => $totalPages,
            'sidebarData' => $sidebarData,
            'sidebarMeta' => $sidebarMeta,
        ]);
    }
}

--- FILE: ./app/Controllers/NavController.php ---

<?php
namespace App\Controllers;

use App\Models\NavModel; 

class NavController
{
    private NavModel $navModel;

    public function __construct()
    {
        $this->navModel = new NavModel();
    }

    /**
     * 指定されたサイトIDに基づいて、サイドメニューに表示するすべての動的データを取得する
     */
/**
     * 指定されたサイトIDに基づいて、サイドメニューに表示するすべての動的データを取得する
     */
    public function getSidebarData(string $siteId): array
    {
        // ----------------------------------------------------------------
        // ★★★ デバッグ箇所 ★★★
        dump('--- サイトIDの確認 ---');
        dump('$siteId: ' . $siteId);

        $actors = $this->navModel->getActors($siteId);
        dump('--- 俳優データ (getActors) ---');
        dump($actors);
        
        // 次の確認対象: getTags
        $tags = $this->navModel->getTags($siteId); 
        dump('--- タグデータ (getTags) ---');
        dump($tags); // ★次にこの出力が表示されるか確認してください

        $series = $this->navModel->getSeries($siteId);
        dump('--- シリーズデータ (getSeries) ---');
        dump($series);

        $brands = $this->navModel->getBrands($siteId);
        dump('--- ブランドデータ (getBrands) ---');
        dump($brands);

        $labels = $this->navModel->getLabels($siteId);
        dump('--- レーベルデータ (getLabels) ---');
        dump($labels);
        
        dump('--- デバッグ終了 ---');
        // ----------------------------------------------------------------

        return [
            'actors'          => $actors,
            'tags'            => $tags,
            'series'          => $series,
            'brands'          => $brands,
            'labels'          => $labels,
        ];
    }
    
    /**
     * サイトIDに基づいてサイドバーのメタ情報（タイトルや静的カテゴリー）を取得する
     */
    public function getSidebarMeta(string $siteId): array
    {
        // 1. サイドバータイトル (sidebarTitle) の決定
        $sidebarTitle = match ($siteId) {
            'okashi' => '💖 アイドル委員会',
            'lemon'  => '🎥 一般向人気作品',
            'b10f'   => '🎬 独占マニアック',
            default  => '人気コンテンツ', // ★ 不正なIDが渡された場合のデフォルトタイトル
        };

        // 2. 静的なカテゴリー (staticCategories) の決定
        $staticCategories = match ($siteId) {
            'lemon', 'b10f' => [ // 'all' を削除
                // $siteId を使ってリンクを生成
                ['name' => '無修正', 'icon' => 'fas fa-ban', 'href' => '/' . $siteId . '/category/uncensored'],
                ['name' => '独占配信', 'icon' => 'fas fa-crown', 'href' => '/' . $siteId . '/category/exclusive'],
                ['name' => '人気女優', 'icon' => 'fas fa-venus-mars', 'href' => '/' . $siteId . '/category/actress'],
            ],
            // 'okashi' または default の場合、okashi のカテゴリー構造を適用
            default => [
                ['name' => 'ドラマ・映画', 'icon' => 'fas fa-film', 'href' => '/' . $siteId . '/category/movie'],
                ['name' => 'アニメ', 'icon' => 'fas fa-mask', 'href' => '/' . $siteId . '/category/anime'],
                ['name' => 'バラエティ', 'icon' => 'fas fa-tv', 'href' => '/' . $siteId . '/category/variety'],
            ],
        };

        return [
            'sidebarTitle' => $sidebarTitle,
            'staticCategories' => $staticCategories,
        ];
    }
}

--- FILE: ./app/Controllers/WorkController.php ---

<?php
namespace App\Controllers;

use App\Models\WorksModel;
use App\Controllers\NavController;
use App\Models\TagModel;
use App\Models\SeriesModel;

class WorkController
{
 /**
     * 単一の作品詳細ページを表示する
     * URL: /work/{workId}
     * @param string $workId 作品ID (例: 'ABC-123')
     */
    public function show(string $workId)
    {
        $worksModel = new WorksModel();
        $tagModel = new TagModel(); // ★★★ この行を追加！ ★★★
        $seriesModel = new SeriesModel(); // ★★★ この行を追加！ ★★★
        
        // 1. 作品の詳細データを取得
        // WorksModel::getWorkDetails(string $workId) は works と work_affiliates を結合して取得
        $work = $worksModel->getWorkDetails($workId); // [cite: 32]

        if (!$work) {
            // 作品が見つからない場合は404エラー
            http_response_code(404);
            \dd("404 Not Found: Work ID '{$workId}' does not exist."); 
        }

        // 2. 関連データの取得と結合 (★★★ 今回の主要な追加ロジック ★★★)

        // 2-1. 女優（アクター）名の取得
        // WorksModel::getActorsByWorkIds は、[workId => 'Name1, Name2'] のマップを返す [cite: 91]
        $actorMap = $worksModel->getActorsByWorkIds([$workId]); // 配列で渡す
        
        // 取得したアクター名を作品データに結合
        $actorNamesString = $actorMap[$workId] ?? null;
        if ($actorNamesString) {
            // 例: '八木奈々, 中井ゆかり' を配列に変換してビューで扱いやすくする
            $work['actor_list'] = array_map('trim', explode(',', $actorNamesString));
        } else {
            $work['actor_list'] = [];
        }
        
        // TODO: シリーズ、タグデータの取得
        // / 2-2. タグデータの取得 (★ New)
        $work['tag_list'] = $tagModel->getTagsByWorkId($workId); // 例: ['ビキニ', '巨乳']

        // 2-3. シリーズ名の取得 (string または null) ★★★ New ★★★
        $seriesName = $seriesModel->getSeriesNameByWorkId($workId);
        
        // シリーズが紐づいていれば work 配列に格納 (空の場合は null を格納)
        $work['series_name'] = $seriesName;

        // 3. サイドバーデータの取得
        $siteId = $work['site_id'];
        $navController = new NavController();
        $sidebarData = $navController->getSidebarData($siteId);

        // 4. Viewにデータを渡してレンダリング
        view('works/show', [
            'title' => $work['title'] . ' | 詳細', 
            'work' => $work,
            'siteId' => $siteId,
            'sidebarData' => $sidebarData,
            // 'actorList' => $work['actor_list'], // work配列内に含めたため不要
        ]);
    }
}

--- FILE: ./app/Controllers/TagController.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/controllers/TagController.php

namespace App\Controllers;

use App\Models\WorksModel;
use App\Models\TagModel;
use App\Controllers\NavController;
use App\Core\Config; 

class TagController
{
    /**
     * 特定のサイトの、特定のタグに紐づく作品一覧を表示するアクション
     */
    public function index(string $arg1, ?string $arg2 = null)
    {
        // ★修正点: 引数の数に応じて $siteId と $tagName を決定
        if ($arg2 === null) {
            // パターン2: /tag/{tagName} の場合
            $siteId = 'all';
            $tagName = $arg1;
        } else {
            // パターン1: /{siteId}/tag/{tagName} の場合
            $siteId = $arg1;
            $tagName = $arg2;
        }

        // 1. 初期設定とURLデコード
        $perPage = Config::get('pagination.works_per_page', 20);
        
        $currentPage = isset($_GET['page']) && is_numeric($_GET['page']) && (int)$_GET['page'] >= 1
                     ? (int)$_GET['page']
                     : 1;
                     
        $offset = ($currentPage - 1) * $perPage;

        // Routerから渡される $tagName はエンコードされている可能性があるため、デコード
        $decodedTagName = urldecode($tagName);

        $worksModel = new WorksModel();
        $tagModel = new TagModel();

        // 2. タグ情報の取得と存在チェック (TagModel::findBySiteIdAndName は別途修正が必要です)
        $tagInfo = $tagModel->findBySiteIdAndName($siteId, $decodedTagName);

        if (!$tagInfo) {
            die("404 Not Found: Tag '{$decodedTagName}' not found for site '{$siteId}'");
        }

        // 3. 作品データの取得
        $works = $worksModel->getWorksByTag($siteId, $decodedTagName, $perPage, $offset);
        
        // 4. 総作品数の取得とページネーションの計算
        $totalWorks = $worksModel->getTotalWorksCountByTag($siteId, $decodedTagName);
        $totalPages = ceil($totalWorks / $perPage);

        // 5. サイドバーデータの取得
        $navController = new NavController();
        $sidebarData = $navController->getSidebarData($siteId); 
        
        // 6. Viewにデータを渡してレンダリング
        view('tag/index', [
            'title' => strtoupper($siteId) . ' | タグ: ' . $decodedTagName . ' の作品一覧', 
            'siteId' => $siteId,
            'tagName' => $decodedTagName,
            'tagInfo' => $tagInfo, 
            'works' => $works,
            'currentPage' => $currentPage, 
            'totalPages' => $totalPages,
            'sidebarData' => $sidebarData,
            
            'tagNameUrl' => $tagName, 
        ]);
    }
}

--- FILE: ./app/Controllers/SeriesController.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/controllers/SeriesController.php

namespace App\Controllers;

use App\Models\WorksModel;
use App\Models\SeriesModel;
use App\Core\Config;
use App\Controllers\NavController;

class SeriesController
{
    public function index(string $siteId, string $seriesName)
    {
        // 1. 初期設定とURLデコード
        $perPage = Config::get('pagination.works_per_page', 20);
        
        $currentPage = isset($_GET['page']) && is_numeric($_GET['page']) && (int)$_GET['page'] >= 1
                     ? (int)$_GET['page']
                     : 1;
                     
        $offset = ($currentPage - 1) * $perPage;

        // Routerから渡される $seriesName はエンコードされている可能性があるため、デコード
        $decodedSeriesName = urldecode($seriesName);

        $worksModel = new WorksModel();
        $seriesModel = new SeriesModel();

        // 2. シリーズ情報の取得と存在チェック
        $seriesInfo = $seriesModel->findBySiteIdAndName($siteId, $decodedSeriesName);

        if (!$seriesInfo) {
            die("404 Not Found: Series '{$decodedSeriesName}' not found for site '{$siteId}'");
        }

        // 3. 作品データの取得
        $works = $worksModel->getWorksBySeries($siteId, $decodedSeriesName, $perPage, $offset);
        
        // 4. 総作品数の取得とページネーションの計算
        $totalWorks = $worksModel->getTotalWorksCountBySeries($siteId, $decodedSeriesName);
        $totalPages = ceil($totalWorks / $perPage);

        // 5. サイドバーデータの取得
        $navController = new NavController();
        $sidebarData = $navController->getSidebarData($siteId); 
        
        // 6. Viewにデータを渡してレンダリング
        view('series/index', [
            'title' => strtoupper($siteId) . ' | シリーズ: ' . $decodedSeriesName . ' の作品一覧', 
            'siteId' => $siteId,
            'seriesName' => $decodedSeriesName,
            'seriesInfo' => $seriesInfo,
            'works' => $works,
            'currentPage' => $currentPage,
            'totalPages' => $totalPages,
            'sidebarData' => $sidebarData,
            
            // ★ 修正点1: tagNameUrl を seriesNameUrl に変更
            'seriesNameUrl' => $seriesName, // URLエンコード済みのシリーズ名を渡す
            // ★ 修正点2: isSeriesPage = true を追加し、シリーズページであることを明示
            'isSeriesPage' => true, 
        ]);
    }
}

--- FILE: ./app/Controllers/ActorController.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/controllers/ActorController.php

namespace App\Controllers;

use App\Models\WorksModel;
use App\Models\ActorModel; // ★ ActorModelを使用
use App\Core\Config;
use App\Controllers\NavController;

class ActorController
{
    public function index(string $siteId, string $actorName) // ★ $actorNameを使用
    {
        // 1. 初期設定とURLデコード
        $perPage = Config::get('pagination.works_per_page', 20);
        
        $currentPage = isset($_GET['page']) && is_numeric($_GET['page']) && (int)$_GET['page'] >= 1
                     ? (int)$_GET['page']
                     : 1;
                     
        $offset = ($currentPage - 1) * $perPage;

        // Routerから渡される $actorName はエンコードされている可能性があるため、デコード
        $decodedActorName = urldecode($actorName);

        $worksModel = new WorksModel();
        $actorModel = new ActorModel(); // ★ ActorModelを使用

        // 2. アクター情報の取得と存在チェック (ActorModel::findBySiteIdAndName)
        $actorInfo = $actorModel->findBySiteIdAndName($siteId, $decodedActorName);

        if (!$actorInfo) {
            // アクターが見つからなかった場合の処理
            die("404 Not Found: Actor '{$decodedActorName}' not found for site '{$siteId}'");
        }

        // 3. 作品データの取得 (WorksModel::getWorksByActor)
        $works = $worksModel->getWorksByActor($siteId, $decodedActorName, $perPage, $offset); // ★ メソッド変更
        
        // dd($works);

        // 4. 総作品数の取得とページネーションの計算 (WorksModel::getTotalWorksCountByActor)
        $totalWorks = $worksModel->getTotalWorksCountByActor($siteId, $decodedActorName); // ★ メソッド変更
        $totalPages = ceil($totalWorks / $perPage);

        // 5. サイドバーデータの取得
        $navController = new NavController();
        $sidebarData = $navController->getSidebarData($siteId); 
        
        // 6. Viewにデータを渡してレンダリング
        // ★ series/index を actor/index (新規作成を推奨) または works/index に渡す
        view('actor/index', [ 
            'title' => strtoupper($siteId) . ' | アクター: ' . $decodedActorName . ' の作品一覧', 
            'siteId' => $siteId,
            'actorName' => $decodedActorName,
            'actorInfo' => $actorInfo,
            'works' => $works,
            'currentPage' => $currentPage,
            'totalPages' => $totalPages,
            'sidebarData' => $sidebarData,
            
            // ページネーションコンポーネント用の変数
            'isActorPage' => true,                   // ★ 新規追加
            'actorNameUrl' => $actorName,            // ★ 新規追加
        ]);
    }
}

--- FILE: ./app/Models/WorksModel.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/Models/WorksModel.php

namespace App\Models;

use App\Core\Database;

class WorksModel
{
    /** @var array 全作品データを格納する配列 (CSV処理用) */
    private array $data = [];

    /** @var array CSVヘッダー（列名）の正確なリスト */
    private array $headers = [
        '商品ID',
        '配信日',
        'タイトル',
        'キャプチャ画像数',
        '広告画像タイプ',
        '広告用ジャケットURL',
        '商品URL',
        'コメント',
        'レンタル視聴を含む最低価格[税込]',
        '収録時間',
        'ブランド',
        'カテゴリー名',
        '出演',
        'どれでもバナー ジャケット型',
        'どれでもバナー プレーヤ型(iframe)型',
        'どれでもバナー 作品名リンク',
        'どれでもバナー 出演作品一覧',
        'どれでもバナー メーカ作品一覧',
        'どれでもバナー レーベル作品一覧',
        'どれでもバナー シリーズ作品一覧',
        'どれでもバナー タグ作品一覧',
        'どれでもバナー キャプチャ1',
        'どれでもバナー キャプチャ2',
        'どれでもバナー キャプチャ3',
        'どれでもバナー キャプチャ4',
        'どれでもバナー キャプチャ5',
        'どれでもバナー キャプチャ6',
        'どれでもバナー キャプチャ7',
        'どれでもバナー キャプチャ8',
        'どれでもバナー キャプチャ9',
        'どれでもバナー キャプチャ10',
        'どれでもバナー キャプチャ11',
        'どれでもバナー キャプチャ12',
        'どれでもバナー キャプチャ13',
        'どれでもバナー キャプチャ14',
        'どれでもバナー キャプチャ15',
        'どれでもバナー キャプチャ16'
    ];

    /** @var int CSVヘッダーの列数 */
    private const FIELD_COUNT = 37;

    // ====================================================================
    // ★★★ CSV連携メソッド (3つのCSVに対応するロジック) ★★★
    // ====================================================================

    /**
     * config.phpで定義されたすべてのCSVファイルを読み込み、データを統合する
     * 3つのCSV（またはそれ以上）に対応するコアロジックです。
     */
    public function loadCsvData(array $csvFiles): void
    {
        $allData = [];
        foreach ($csvFiles as $label => $path) {
            if (!file_exists($path)) {
                error_log("Warning: CSV file not found for label '{$label}' at {$path}");
                continue;
            }

            if (($handle = fopen($path, 'r')) !== false) {
                // 1. ヘッダー行をスキップ
                if (fgetcsv($handle, 0, ',') === false) {
                    fclose($handle);
                    continue;
                }

                // 2. データ行の処理
                while (($dataRow = fgetcsv($handle, 0, ',')) !== false) {
                    if (count($dataRow) !== self::FIELD_COUNT) {
                        error_log("Skipping row in {$label}.csv due to field count mismatch. Expected: " . self::FIELD_COUNT . ", Actual: " . count($dataRow));
                        continue;
                    }

                    $rowData = array_combine($this->headers, $dataRow);
                    $workId = $rowData['商品ID'] ?? null;

                    if ($workId) {
                        // 商品IDをキーとしてデータを統合（後続のCSVで上書き可能）
                        $allData[$workId] = $rowData;
                    }
                }
                fclose($handle);
            }
        }
        $this->data = $allData;
    }

    /**
     * CSVデータから最新の作品を取得する (DBが使用できない場合の代替)
     */
    public function getLatestWorksFromCsv(int $limit): array
    {
        // loadCsvData() が実行されている前提
        // 配列のキーを維持しつつ、先頭から指定数だけ切り出す
        return array_slice($this->data, 0, $limit, true);
    }

    // ====================================================================
    // ★★★ コア作品取得メソッド (サイト別/全サイト) ★★★
    // ====================================================================

    /**
     * 特定のサイトIDに紐づく最新の作品を取得する
     */
    public function getLatestWorks(string $siteId, int $limit, int $offset = 0): array
    {
        $sql = "SELECT w.*, wa.link_title, wa.capture_1_link
                FROM works w
                JOIN work_affiliates wa ON w.work_id = wa.work_id AND wa.site_id = w.site_id
                WHERE w.site_id = :siteId  -- サイトIDで絞り込み
                ORDER BY w.release_date DESC, w.id DESC 
                LIMIT :limit OFFSET :offset";

        $pdo = Database::getConnection();
        $stmt = $pdo->prepare($sql);
        $stmt->bindValue(':siteId', $siteId, \PDO::PARAM_STR);
        $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
        $stmt->bindValue(':offset', $offset, \PDO::PARAM_INT);
        $stmt->execute();

        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * 特定のサイトIDに紐づく総作品数を取得する
     */
    public function getTotalWorksCount(string $siteId): int
    {
        $totalSql = "SELECT COUNT(*) FROM works WHERE site_id = :siteId";

        $pdo = Database::getConnection();
        $stmt = $pdo->prepare($totalSql);
        $stmt->bindValue(':siteId', $siteId, \PDO::PARAM_STR);
        $stmt->execute();

        return (int) $stmt->fetchColumn();
    }

    /**
     * 全サイトの最新作品を取得する
     */
    public function getLatestWorksAllSites(int $limit, int $offset = 0): array
    {
        $sql = "
            SELECT 
                w.*, 
                wa.link_title, 
                wa.capture_1_link
            FROM 
                works w
            LEFT JOIN 
                work_affiliates wa ON w.work_id = wa.work_id AND wa.site_id = w.site_id
            ORDER BY 
                w.release_date DESC, w.id DESC
            LIMIT :limit OFFSET :offset
        ";

        $pdo = Database::getConnection();
        $stmt = $pdo->prepare($sql);
        $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
        $stmt->bindValue(':offset', $offset, \PDO::PARAM_INT);
        $stmt->execute();

        $works = $stmt->fetchAll(\PDO::FETCH_ASSOC);

        // PHP側でアクター情報を結合するためのロジック
        $workIds = array_column($works, 'work_id');
        $actorMap = $this->getActorsByWorkIds($workIds);

        foreach ($works as &$work) {
            $work['actor_names'] = $actorMap[$work['work_id']] ?? '';
        }

        return $works;
    }

    /**
     * 全サイトの総作品数を取得する
     */
    public function getTotalWorksCountAllSites(): int
    {
        $totalSql = "SELECT COUNT(*) FROM works";
        $pdo = Database::getConnection();
        // WHERE句なし
        return (int) $pdo->query($totalSql)->fetchColumn();
    }

    /**
     * 単一の作品IDに基づき、全ての詳細データ（works & work_affiliates）を取得する
     */
    public function getWorkDetails(string $workId): ?array
    {
        // work_affiliates のデータもまとめて取得
        $sql = "SELECT w.*, wa.link_title, wa.capture_1_link, wa.capture_2_link, wa.capture_3_link
                FROM works w
                JOIN work_affiliates wa ON w.work_id = wa.work_id AND wa.site_id = w.site_id
                WHERE w.work_id = :workId
                LIMIT 1";

        $pdo = Database::getConnection();
        $stmt = $pdo->prepare($sql);
        $stmt->bindValue(':workId', $workId, \PDO::PARAM_STR);
        $stmt->execute();
        $work = $stmt->fetch(\PDO::FETCH_ASSOC);

        // TODO: ここで作品に関連する出演者、タグなどのデータを取得・結合するロジックを追加する必要があります。

        return $work ?: null;
    }

    // ====================================================================
    // ★★★ 属性別作品検索メソッド (タグ/シリーズ/アクター) ★★★
    // ====================================================================

/**
     * 特定のサイトIDとタグ名に紐づく作品リストを取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $tagName タグ名
     * @param int $perPage 1ページあたりの件数
     * @param int $offset オフセット
     * @return array 作品データの配列
     */
    public function getWorksByTag(
        string $siteId,
        string $tagName,
        int $perPage,
        int $offset
    ): array {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "t.name COLLATE utf8mb4_general_ci = :tag_name";
            $params = [
                ':tag_name' => $tagName, 
                ':limit' => $perPage, 
                ':offset' => $offset,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用 (サイトID 'all' の処理を排除)
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";
            
            // 2. クエリの構築
            $sql = "
                SELECT 
                    w.*,
                    GROUP_CONCAT(DISTINCT a.name) AS actor_names,
                    b.name AS brand_name
                FROM 
                    works w
                INNER JOIN 
                    work_tags wt ON w.work_id COLLATE utf8mb4_general_ci = wt.work_id
                INNER JOIN 
                    tags t ON wt.tag_id = t.id
                LEFT JOIN
                    work_actors wa ON w.work_id COLLATE utf8mb4_general_ci = wa.work_id
                LEFT JOIN
                    actors a ON wa.actor_id = a.id
                LEFT JOIN
                    work_brands wb ON w.work_id COLLATE utf8mb4_general_ci = wb.work_id AND w.site_id COLLATE utf8mb4_general_ci = wb.site_id
                LEFT JOIN
                    brands b ON wb.brand_id = b.id
                WHERE 
                    {$where}
                GROUP BY 
                    w.work_id, w.site_id
                ORDER BY 
                    w.release_date DESC, w.id DESC
                LIMIT :limit 
                OFFSET :offset;
            ";

            // 3. プリペアドステートメントの準備とバインド
            $stmt = $pdo->prepare($sql);

            foreach ($params as $key => &$val) {
                if ($key === ':limit' || $key === ':offset') {
                    // LIMIT/OFFSETは整数としてバインド
                    $stmt->bindValue($key, $val, \PDO::PARAM_INT);
                } else {
                    // その他は文字列としてバインド
                    $stmt->bindValue($key, $val, \PDO::PARAM_STR);
                }
            }
            
            // クエリの実行
            $stmt->execute();
            return $stmt->fetchAll(\PDO::FETCH_ASSOC);
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getWorksByTag): " . $e->getMessage());
            return [];
        }
    }

/**
     * 特定のタグに紐づく総作品数を取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $tagName タグ名
     * @return int 総作品数
     */
    public function getTotalWorksCountByTag(string $siteId, string $tagName): int
    {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "t.name COLLATE utf8mb4_general_ci = :tag_name";
            $params = [
                ':tag_name' => $tagName,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";

            // 2. クエリの構築
            $sql = "
                SELECT 
                    COUNT(DISTINCT w.work_id) 
                FROM 
                    works w
                JOIN 
                    work_tags wt ON w.work_id COLLATE utf8mb4_general_ci = wt.work_id
                JOIN
                    tags t ON wt.tag_id = t.id
                WHERE 
                    {$where}
            ";
            
            // 3. プリペアドステートメントの準備と実行
            $stmt = $pdo->prepare($sql);
            
            // パラメータのバインド
            foreach ($params as $key => &$val) {
                 $stmt->bindValue($key, $val, \PDO::PARAM_STR);
            }
            
            // クエリの実行
            $stmt->execute();
            
            // 結果の取得と返却
            return (int)$stmt->fetchColumn();
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getTotalWorksCountByTag): " . $e->getMessage());
            return 0;
        }
    }

/**
     * 特定のサイトIDとブランド名に紐づく総作品数を取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $brandName ブランド名
     * @return int 総作品数
     */
    public function getTotalWorksCountByBrand(string $siteId, string $brandName): int
    {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
        
            // 1. WHERE句とパラメータの準備
            $where = "b.name COLLATE utf8mb4_general_ci = :brand_name"; 
            $params = [
                ':brand_name' => $brandName,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];

            // ★ 修正済み: site_idによる絞り込みを常に適用 (サイトID 'all' の処理を排除)
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";

            // 2. クエリの構築
            $sql = "
                SELECT 
                    COUNT(DISTINCT w.work_id) 
                FROM 
                    works w
                INNER JOIN
                    work_brands wb ON w.work_id COLLATE utf8mb4_general_ci = wb.work_id 
                                   AND w.site_id COLLATE utf8mb4_general_ci = wb.site_id
                INNER JOIN
                    brands b ON wb.brand_id = b.id
                WHERE 
                    {$where}
            ";
            
            // 3. プリペアドステートメントの準備と実行
            $stmt = $pdo->prepare($sql);
            
            // パラメータのバインド
            foreach ($params as $key => &$val) {
                 $stmt->bindValue($key, $val, \PDO::PARAM_STR);
            }
            
            // クエリの実行
            $stmt->execute();
            
            // 結果の取得と返却
            return (int)$stmt->fetchColumn();
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getTotalWorksCountByBrand): " . $e->getMessage());
            return 0;
        }
    }


/**
     * 特定のサイトIDとシリーズ名に紐づく作品リストを取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $seriesName シリーズ名
     * @param int $perPage 1ページあたりの件数
     * @param int $offset オフセット
     * @return array 作品データの配列
     */
    public function getWorksBySeries(
        string $siteId,
        string $seriesName,
        int $perPage,
        int $offset
    ): array {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "s.name COLLATE utf8mb4_general_ci = :series_name";
            $params = [
                ':series_name' => $seriesName, 
                ':limit' => $perPage, 
                ':offset' => $offset,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";
            
            // 2. クエリの構築
            $sql = "
                SELECT 
                    w.*,
                    GROUP_CONCAT(DISTINCT a.name) AS actor_names,
                    b.name AS brand_name
                FROM 
                    works w
                INNER JOIN 
                    work_series ws ON w.work_id COLLATE utf8mb4_general_ci = ws.work_id
                INNER JOIN 
                    series s ON ws.series_id = s.id
                LEFT JOIN
                    work_actors wa ON w.work_id COLLATE utf8mb4_general_ci = wa.work_id
                LEFT JOIN
                    actors a ON wa.actor_id = a.id
                LEFT JOIN
                    work_brands wb ON w.work_id COLLATE utf8mb4_general_ci = wb.work_id AND w.site_id COLLATE utf8mb4_general_ci = wb.site_id
                LEFT JOIN
                    brands b ON wb.brand_id = b.id
                WHERE 
                    {$where}
                GROUP BY 
                    w.work_id, w.site_id
                ORDER BY 
                    w.release_date DESC, w.id DESC
                LIMIT :limit 
                OFFSET :offset;
            ";

            // 3. プリペアドステートメントの準備とバインド
            $stmt = $pdo->prepare($sql);

            foreach ($params as $key => &$val) {
                if ($key === ':limit' || $key === ':offset') {
                    $stmt->bindValue($key, $val, \PDO::PARAM_INT);
                } else {
                    $stmt->bindValue($key, $val, \PDO::PARAM_STR);
                }
            }
            
            // クエリの実行
            $stmt->execute();
            return $stmt->fetchAll(\PDO::FETCH_ASSOC);
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getWorksBySeries): " . $e->getMessage());
            return [];
        }
    }

/**
     * 特定のシリーズに紐づく総作品数を取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $seriesName シリーズ名
     * @return int 総作品数
     */
    public function getTotalWorksCountBySeries(string $siteId, string $seriesName): int
    {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "s.name COLLATE utf8mb4_general_ci = :series_name";
            $params = [
                ':series_name' => $seriesName,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";

            // 2. クエリの構築
            $sql = "
                SELECT 
                    COUNT(DISTINCT w.work_id) 
                FROM 
                    works w
                JOIN 
                    work_series ws ON w.work_id COLLATE utf8mb4_general_ci = ws.work_id
                JOIN
                    series s ON ws.series_id = s.id
                WHERE 
                    {$where}
            ";
            
            // 3. プリペアドステートメントの準備と実行
            $stmt = $pdo->prepare($sql);
            
            // パラメータのバインド
            foreach ($params as $key => &$val) {
                 $stmt->bindValue($key, $val, \PDO::PARAM_STR);
            }
            
            // クエリの実行
            $stmt->execute();
            return (int)$stmt->fetchColumn();
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getTotalWorksCountBySeries): " . $e->getMessage());
            return 0;
        }
    }

/**
     * 特定のサイトIDと出演者名に紐づく作品リストを取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $actorName 出演者名
     * @param int $perPage 1ページあたりの件数
     * @param int $offset オフセット
     * @return array 作品データの配列
     */
    public function getWorksByActor(
        string $siteId,
        string $actorName,
        int $perPage,
        int $offset
    ): array {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "a.name COLLATE utf8mb4_general_ci = :actor_name";
            $params = [
                ':actor_name' => $actorName, 
                ':limit' => $perPage, 
                ':offset' => $offset,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";
            
            // 2. クエリの構築
            // NOTE: GROUP_CONCAT(a.name) を使うと、検索対象の俳優以外の名前も含まれるため、a.nameのエイリアスは使わない
            $sql = "
                SELECT 
                    w.*,
                    (SELECT GROUP_CONCAT(DISTINCT a2.name) FROM work_actors wa2 JOIN actors a2 ON wa2.actor_id = a2.id WHERE wa2.work_id = w.work_id) AS actor_names,
                    b.name AS brand_name
                FROM 
                    works w
                INNER JOIN 
                    work_actors wa ON w.work_id COLLATE utf8mb4_general_ci = wa.work_id
                INNER JOIN 
                    actors a ON wa.actor_id = a.id
                LEFT JOIN
                    work_brands wb ON w.work_id COLLATE utf8mb4_general_ci = wb.work_id AND w.site_id COLLATE utf8mb4_general_ci = wb.site_id
                LEFT JOIN
                    brands b ON wb.brand_id = b.id
                WHERE 
                    {$where}
                GROUP BY 
                    w.work_id, w.site_id
                ORDER BY 
                    w.release_date DESC, w.id DESC
                LIMIT :limit 
                OFFSET :offset;
            ";

            // 3. プリペアドステートメントの準備とバインド
            $stmt = $pdo->prepare($sql);

            foreach ($params as $key => &$val) {
                if ($key === ':limit' || $key === ':offset') {
                    $stmt->bindValue($key, $val, \PDO::PARAM_INT);
                } else {
                    $stmt->bindValue($key, $val, \PDO::PARAM_STR);
                }
            }
            
            // クエリの実行
            $stmt->execute();
            return $stmt->fetchAll(\PDO::FETCH_ASSOC);
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getWorksByActor): " . $e->getMessage());
            return [];
        }
    }

/**
     * 特定の出演者に紐づく総作品数を取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $actorName 出演者名
     * @return int 総作品数
     */
    public function getTotalWorksCountByActor(string $siteId, string $actorName): int
    {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "a.name COLLATE utf8mb4_general_ci = :actor_name";
            $params = [
                ':actor_name' => $actorName,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";

            // 2. クエリの構築
            $sql = "
                SELECT 
                    COUNT(DISTINCT w.work_id) 
                FROM 
                    works w
                JOIN 
                    work_actors wa ON w.work_id COLLATE utf8mb4_general_ci = wa.work_id
                JOIN
                    actors a ON wa.actor_id = a.id
                WHERE 
                    {$where}
            ";
            
            // 3. プリペアドステートメントの準備と実行
            $stmt = $pdo->prepare($sql);
            
            // パラメータのバインド
            foreach ($params as $key => &$val) {
                 $stmt->bindValue($key, $val, \PDO::PARAM_STR);
            }
            
            // クエリの実行
            $stmt->execute();
            return (int)$stmt->fetchColumn();
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getTotalWorksCountByActor): " . $e->getMessage());
            return 0;
        }
    }

    // ====================================================================
    // ★★★ 作品データ永続化 (UPSERT) メソッド ★★★
    // ====================================================================

    /**
     * worksテーブルに作品データを挿入または更新する（UPSERT）
     */
    public function insertOrUpdateWork(array $data): bool
    {
        $pdo = Database::getConnection();
        // 挿入するカラムと値
        $columns = array_keys($data);
        $placeholders = array_map(fn($col) => ":$col", $columns);

        // ON DUPLICATE KEY UPDATE 句を生成 (主キー以外を更新対象とする)
        $updateFields = [];
        foreach ($columns as $col) {
            if ($col !== 'work_id' && $col !== 'site_id') {
                $updateFields[] = "$col = VALUES($col)";
            }
        }
        $updateClause = implode(', ', $updateFields);

        $sql = "
            INSERT INTO works (" . implode(', ', $columns) . ") 
            VALUES (" . implode(', ', $placeholders) . ") 
            ON DUPLICATE KEY UPDATE 
                $updateClause
        ";

        try {
            $stmt = $pdo->prepare($sql);
            // データをバインド
            foreach ($data as $key => &$value) {
                // bindParamは参照渡しが必要なため、&$valueを使用
                $stmt->bindParam(":$key", $value);
            }
            return $stmt->execute();
        } catch (\PDOException $e) {
            error_log("WorksModel insertOrUpdateWork DB Error: " . $e->getMessage());
            return false;
        }
    }

    /**
     * work_affiliates テーブルにアフィリエイトリンクデータを挿入または更新する (UPSERT)
     */
    public function insertOrUpdateWorkAffiliates(int $workId, string $siteId, array $affiliateData): bool
    {
        $pdo = Database::getConnection();

        // 必須データ (work_id, site_id) とタイムスタンプを追加
        $data = array_merge([
            'work_id' => $workId,
            'site_id' => $siteId,
            'updated_at' => date('Y-m-d H:i:s')
        ], $affiliateData);

        // 挿入するカラムとプレースホルダ
        $columns = array_keys($data);
        $placeholders = array_map(fn($col) => ":$col", $columns);

        // ON DUPLICATE KEY UPDATE 句を生成 (work_id, site_id, id 以外を更新対象とする)
        $updateFields = [];
        foreach ($columns as $col) {
            if ($col !== 'work_id' && $col !== 'site_id' && $col !== 'id') {
                $updateFields[] = "$col = VALUES($col)";
            }
        }

        // 更新対象がない場合でも、updated_atは更新対象とする
        $updateClause = implode(', ', $updateFields);
        if (empty($updateClause)) {
            $updateClause = "updated_at = VALUES(updated_at)";
        }

        $sql = "
            INSERT INTO work_affiliates (" . implode(', ', $columns) . ") 
            VALUES (" . implode(', ', $placeholders) . ") 
            ON DUPLICATE KEY UPDATE 
                $updateClause
        ";

        try {
            $stmt = $pdo->prepare($sql);
            foreach ($data as $key => &$value) {
                // work_id は INT、その他は STR としてバインド
                $paramType = ($key === 'work_id') ? \PDO::PARAM_INT : \PDO::PARAM_STR;
                $stmt->bindValue(":$key", $value, $paramType);
            }
            return $stmt->execute();
        } catch (\PDOException $e) {
            error_log("WorksModel insertOrUpdateWorkAffiliates DB Error: " . $e->getMessage());
            return false;
        }
    }


    // ====================================================================
    // ★★★ 関連エンティティ (マスターデータ & 関連付け) メソッド ★★★
    // ====================================================================

    // --- アクター/女優関連 ---

    /**
     * 複数の作品IDに基づき、アクター名リストを取得する
     */
    public function getActorsByWorkIds(array $workIds): array
    {
        if (empty($workIds)) {
            return [];
        }

        // プレースホルダを生成 (例: ?, ?, ?)
        $placeholders = implode(', ', array_fill(0, count($workIds), '?'));
        $sql = "
            SELECT 
                w_a.work_id,
                GROUP_CONCAT(a.name ORDER BY a.id SEPARATOR ', ') AS actor_names
            FROM 
                work_actors w_a
            JOIN
                actors a ON w_a.actor_id = a.id
            WHERE
                w_a.work_id IN ({$placeholders})
            GROUP BY 
                w_a.work_id
        ";

        $pdo = Database::getConnection();
        $stmt = $pdo->prepare($sql);

        // work_idの配列を直接バインド
        $stmt->execute($workIds);

        // work_idをキー、actor_namesを値とする連想配列に変換
        $results = $stmt->fetchAll(\PDO::FETCH_ASSOC);

        $actorMap = [];
        foreach ($results as $row) {
            $actorMap[$row['work_id']] = $row['actor_names'];
        }

        return $actorMap;
    }

    /**
     * 女優を挿入またはIDを取得し、actor_sitesテーブルに関連付けを登録する
     */
    public function insertOrGetActor(string $actorNameRaw, string $siteId): int
    {
        // 女優名から前後の空白を削除
        $actorName = trim($actorNameRaw);
        if (empty($actorName)) {
            return 0;
        }

        $pdo = Database::getConnection();
        // 1. actorsテーブル: 存在チェック
        $sql = "SELECT id FROM actors WHERE name = :name";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([':name' => $actorName]);
        $actorId = $stmt->fetchColumn();

        // 2. actorsテーブル: 挿入
        if (!$actorId) {
            $sql = "INSERT INTO actors (name) VALUES (:name)";
            $stmt = $pdo->prepare($sql);
            $stmt->execute([':name' => $actorName]);
            $actorId = $pdo->lastInsertId();
        }

        $actorId = (int)$actorId;
        if ($actorId > 0) {
            // 3. actor_sitesテーブルへの関連付け (UPSERT)
            $sqlActorSite = "
                INSERT INTO actor_sites (actor_id, site_id) 
                VALUES (:actor_id, :site_id)
                ON DUPLICATE KEY UPDATE 
                actor_id = actor_id
            ";
            $stmtActorSite = $pdo->prepare($sqlActorSite);
            $stmtActorSite->bindValue(':actor_id', $actorId, \PDO::PARAM_INT);
            $stmtActorSite->bindValue(':site_id', $siteId, \PDO::PARAM_STR);
            $stmtActorSite->execute();
        }

        return $actorId;
    }

    /**
     * work_actorsテーブルに作品と女優の関連付けを挿入/更新する
     */
    public function insertWorkActorLink($workId, $siteId, $actorId) // 型ヒントと戻り値の型宣言は削除された状態で再構築
    {
        $pdo = Database::getConnection();
        // 既存の関連付けを削除（上書き対応）
        $deleteSql = "DELETE FROM work_actors WHERE work_id = :work_id AND site_id = :site_id";
        $deleteStmt = $pdo->prepare($deleteSql);
        $deleteStmt->execute([':work_id' => $workId, ':site_id' => $siteId]);

        // 新しい関連付けを挿入 (INSERT IGNORE)
        $sql = "INSERT IGNORE INTO work_actors 
            (work_id, site_id, actor_id) 
            VALUES 
            (:work_id, :site_id, :actor_id)";
        try {
            $stmt = $pdo->prepare($sql);
            return $stmt->execute([
                ':work_id' => $workId,
                ':site_id' => $siteId,
                ':actor_id' => $actorId,
            ]);
        } catch (\PDOException $e) {
            error_log("WorksModel insertWorkActorLink DB Error: " . $e->getMessage());
            return false;
        }
    }


    // --- タグ関連 ---

    /**
     * タグを挿入またはIDを取得し、tag_sitesテーブルに関連付けを登録する
     */
    public function insertOrGetTag(string $tagNameRaw, string $siteId): int
    {
        $tagName = trim($tagNameRaw);
        if (empty($tagName)) {
            return 0;
        }

        $pdo = Database::getConnection();
        // 1. tagsテーブル: 存在チェック
        $sql = "SELECT id FROM tags WHERE name = :name";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([':name' => $tagName]);
        $tagId = $stmt->fetchColumn();

        // 2. tagsテーブル: 挿入
        if (!$tagId) {
            $sql = "INSERT INTO tags (name) VALUES (:name)";
            $stmt = $pdo->prepare($sql);
            $stmt->execute([':name' => $tagName]);
            $tagId = $pdo->lastInsertId();
        }

        $tagId = (int)$tagId;
        if ($tagId > 0) {
            // 3. tag_sitesテーブルへの関連付け (UPSERT)
            $sqlTagSite = "
                INSERT INTO tag_sites (tag_id, site_id) 
                VALUES (:tag_id, :site_id)
                ON DUPLICATE KEY UPDATE 
                tag_id = tag_id /* 主キーを自分自身で更新し、エラーを回避 */
            ";
            $stmtTagSite = $pdo->prepare($sqlTagSite);
            $stmtTagSite->bindValue(':tag_id', $tagId, \PDO::PARAM_INT);
            $stmtTagSite->bindValue(':site_id', $siteId, \PDO::PARAM_STR);
            $stmtTagSite->execute();
        }

        return $tagId;
    }

    /**
     * work_tagsテーブルに作品とタグの関連付けを挿入/更新する
     */
    public function insertWorkTags(string $workId, string $siteId, array $tagNames): bool
    {
        $pdo = Database::getConnection();
        // 1. 既存の関連付けを削除（上書き）
        $deleteSql = "DELETE FROM work_tags WHERE work_id = :work_id AND site_id = :site_id";
        $deleteStmt = $pdo->prepare($deleteSql);
        $deleteStmt->execute([':work_id' => $workId, ':site_id' => $siteId]);

        if (empty($tagNames)) {
            return true;
        }

        // 2. 新しい関連付けを挿入
        $sql = "INSERT IGNORE INTO work_tags (work_id, site_id, tag_id) VALUES (:work_id, :site_id, :tag_id)";
        try {
            $stmt = $pdo->prepare($sql);
            foreach ($tagNames as $tagName) {
                // タグマスターに登録しIDを取得
                $tagId = $this->insertOrGetTag($tagName, $siteId);

                // 関連付けを挿入
                if ($tagId > 0) {
                    $stmt->execute([
                        ':work_id' => $workId,
                        ':site_id' => $siteId,
                        ':tag_id' => $tagId,
                    ]);
                }
            }
            return true;
        } catch (\PDOException $e) {
            error_log("WorksModel insertWorkTags DB Error: " . $e->getMessage());
            return false;
        }
    }
   

/**
     * ブランドを挿入またはIDを取得し、brands_sitesテーブルに関連付けを登録する
     * ※ 以前の同名メソッドの重複を解消しF、サイトIDを引数に取るロジックに統一
     * * @param string $brandNameRaw 処理前のブランド名
     * @param string $siteId 関連付けるサイトID
     * @return int 挿入または取得したブランドID (失敗時は0)
     */
    public function insertOrGetBrand(string $brandNameRaw, string $siteId): int
    {
        $brandName = trim($brandNameRaw);
        if (empty($brandName)) {
            return 0;
        }

        $pdo = \App\Core\Database::getConnection();
        
        try {
            // データの一貫性を保つためトランザクションを開始
            $pdo->beginTransaction(); 

            // 1. brandsテーブル: 存在チェック
            $sql = "SELECT id FROM brands WHERE name = :name";
            $stmt = $pdo->prepare($sql);
            $stmt->execute([':name' => $brandName]);
            $brandId = $stmt->fetchColumn();

            // 2. brandsテーブル: 挿入
            if (!$brandId) {
                // 必須カラムを全て含めたSQL
                $sql = "
                    INSERT INTO brands (name, work_count, created_at, updated_at) 
                    VALUES (:name, 0, NOW(), NOW())
                ";
                $stmt = $pdo->prepare($sql);
                $stmt->execute([':name' => $brandName]);
                $brandId = $pdo->lastInsertId();
            }

            $brandId = (int)$brandId;

            // 3. brands_sitesテーブルへの関連付け (UPSERT)
            if ($brandId > 0) {
                $sqlBrandSite = " 
                    INSERT INTO brands_sites (brand_id, site_id) 
                    VALUES (:brand_id, :site_id)
                    ON DUPLICATE KEY UPDATE 
                    brand_id = VALUES(brand_id)
                ";
                $stmtBrandSite = $pdo->prepare($sqlBrandSite);
                $stmtBrandSite->bindValue(':brand_id', $brandId, \PDO::PARAM_INT);
                $stmtBrandSite->bindValue(':site_id', $siteId, \PDO::PARAM_STR);
                $stmtBrandSite->execute();
            }

            // 全ての処理が成功したらコミット
            $pdo->commit();
            return $brandId;
        } catch (\PDOException $e) {
            // エラーが発生したらロールバック
            if ($pdo->inTransaction()) {
                $pdo->rollBack();
            }
            error_log("WorksModel insertOrGetBrand DB Error: " . $e->getMessage());
            return 0;
        }
    }

    /**
     * work_brandsテーブルに作品とブランドの関連付けを挿入/更新する
     * ※ 以前の同名メソッドの重複を解消し、引数名をbrandIdに統一
     * * @param string $workId 作品ID
     * @param string $siteId サイトID
     * @param int $brandId ブランドID
     * @param string $linkHtml リンクHTML
     * @return bool 実行成功/失敗
     */
    public function insertWorkBrandLink(string $workId, string $siteId, int $brandId, string $linkHtml): bool
    {
        $pdo = \App\Core\Database::getConnection();
        $sql = " 
            INSERT INTO work_brands (work_id, site_id, brand_id, link_html) 
            VALUES (:work_id, :site_id, :brand_id, :link_html) 
            ON DUPLICATE KEY UPDATE 
            brand_id = VALUES(brand_id),
            link_html = VALUES(link_html)
        ";
        try {
            $stmt = $pdo->prepare($sql);
            
            // パラメータのバインド (省略なし)
            $stmt->bindValue(':work_id', $workId, \PDO::PARAM_STR);
            $stmt->bindValue(':site_id', $siteId, \PDO::PARAM_STR);
            $stmt->bindValue(':brand_id', $brandId, \PDO::PARAM_INT);
            $stmt->bindValue(':link_html', $linkHtml, \PDO::PARAM_STR);
            
            // クエリの実行
            return $stmt->execute();
        } catch (\PDOException $e) {
            error_log("WorksModel insertWorkBrandLink DB Error: " . $e->getMessage());
            return false;
        }
    }


    /**
     * レーベルを挿入またはIDを取得する
     */
    public function insertOrGetLabel(string $labelName): int
    {
        $db = Database::getConnection();
        // 1. 既存のレーベル名で検索 
        $sql = "SELECT id FROM labels WHERE name = ?"; // idカラムを仮定
        $stmt = $db->prepare($sql);
        $stmt->execute([$labelName]);
        $labelId = $stmt->fetchColumn();

        if ($labelId) {
            return (int)$labelId;
        }

        // 2. 挿入
        $sql = "INSERT INTO labels (name, work_count) VALUES (?, 0)"; // work_countを仮定
        $stmt = $db->prepare($sql);
        $stmt->execute([$labelName]);
        return (int)$db->lastInsertId();
    }

    /**
     * work_labelsテーブルに作品とレーベルの関連付けを挿入/更新する
     */
    public function insertWorkLabelLink(string $workId, string $siteId, int $labelId, string $linkHtml): bool
    {
        $pdo = Database::getConnection();
        $sql = "
            INSERT INTO work_labels 
                (work_id, site_id, label_id, link_html) 
            VALUES 
                (:work_id, :site_id, :label_id, :link_html)
            ON DUPLICATE KEY UPDATE 
                label_id = VALUES(label_id), 
                link_html = VALUES(link_html)
        ";
        try {
            $stmt = $pdo->prepare($sql);
            return $stmt->execute([
                ':work_id' => $workId,
                ':site_id' => $siteId,
                ':label_id' => $labelId,
                ':link_html' => $linkHtml,
            ]);
        } catch (\PDOException $e) {
            error_log("WorksModel insertWorkLabelLink DB Error: " . $e->getMessage());
            return false;
        }
    }

    // --- シリーズ関連 ---

    /**
     * シリーズを挿入またはIDを取得する
     */
    public function insertOrGetSeries(string $seriesName, string $siteId): int
    {
        $seriesName = trim($seriesName);
        if (empty($seriesName)) {
            return 0;
        }

        $pdo = Database::getConnection();
        // 1. seriesテーブル: 存在チェック
        $sql = "SELECT id FROM series WHERE name = :name";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([':name' => $seriesName]);
        $seriesId = $stmt->fetchColumn();

        // 2. seriesテーブル: 挿入
        if (!$seriesId) {
            // work_count も 0 で挿入
            $sql = "INSERT INTO series (name, work_count) VALUES (:name, 0)";
            $stmt = $pdo->prepare($sql);
            $stmt->execute([':name' => $seriesName]);
            $seriesId = $pdo->lastInsertId();
        }

        $seriesId = (int)$seriesId;
        if ($seriesId > 0) {
            // 3. series_sitesテーブルへの関連付け (UPSERT)
            $sqlSeriesSite = "
                INSERT INTO series_sites (series_id, site_id) 
                VALUES (:series_id, :site_id)
                ON DUPLICATE KEY UPDATE 
                series_id = series_id
            ";
            $stmtSeriesSite = $pdo->prepare($sqlSeriesSite);
            $stmtSeriesSite->bindValue(':series_id', $seriesId, \PDO::PARAM_INT);
            $stmtSeriesSite->bindValue(':site_id', $siteId, \PDO::PARAM_STR);
            $stmtSeriesSite->execute();
        }

        return $seriesId;
    }

    /**
     * work_seriesテーブルに作品とシリーズの関連付けを挿入/更新する
     */
    public function insertWorkSeriesLink(string $workId, string $siteId, int $seriesId, string $linkHtml): bool
    {
        $pdo = Database::getConnection();
        $sql = "
            INSERT INTO work_series 
                (work_id, site_id, series_id, link_html) 
            VALUES 
                (:work_id, :site_id, :series_id, :link_html)
            ON DUPLICATE KEY UPDATE 
                series_id = VALUES(series_id), 
                link_html = VALUES(link_html)
        ";
        try {
            $stmt = $pdo->prepare($sql);
            return $stmt->execute([
                ':work_id' => $workId,
                ':site_id' => $siteId,
                ':series_id' => $seriesId,
                ':link_html' => $linkHtml,
            ]);
        } catch (\PDOException $e) {
            error_log("WorksModel insertWorkSeriesLink DB Error: " . $e->getMessage());
            return false;
        }
    }

    // --- キャプチャ画像関連 ---

    /**
     * キャプチャ画像の情報をwork_capturesテーブルに挿入する
     */
    public function insertCaptures(string $workId, string $siteId, array $captures): bool
    {
        $pdo = Database::getConnection();
        // 既存のデータを削除 (インポート時の上書き対応)
        $deleteSql = "DELETE FROM work_captures WHERE work_id = :work_id AND site_id = :site_id";
        $deleteStmt = $pdo->prepare($deleteSql);
        $deleteStmt->execute([':work_id' => $workId, ':site_id' => $siteId]);

        // 新しいデータを挿入
        $sql = "INSERT INTO work_captures 
            (work_id, site_id, capture_number, image_url, link_html) 
            VALUES 
            (:work_id, :site_id, :capture_number, :image_url, :link_html)";
        try {
            $stmt = $pdo->prepare($sql);
            foreach ($captures as $capture) {
                $stmt->execute([
                    ':work_id'         => $workId,
                    ':site_id'         => $siteId,
                    ':capture_number'  => $capture['capture_number'],
                    ':image_url'       => $capture['image_url'],
                    ':link_html'       => $capture['link_html'],
                ]);
            }
            return true;
        } catch (\PDOException $e) {
            error_log("WorksModel insertCaptures DB Error: " . $e->getMessage());
            return false;
        }
    }


    // ====================================================================
    // ★★★ カウント再計算メソッド (分離・修正) ★★★
    // ====================================================================

    /**
     * アクター、タグ、ブランド（メーカー）の work_count を再計算し更新する
     */
    public function recalculateCounts(): void
    {
        $pdo = Database::getConnection();

        // ----------------------------------------------------------------------
        // 1. ブランド (brands ) カウントの再計算
        // ----------------------------------------------------------------------
        $sqlBrand = "
            UPDATE brands b
            JOIN (
                SELECT brand_id, COUNT(work_id) as count
                FROM work_brands
                GROUP BY brand_id
            ) AS wb_counts
            ON b.id = wb_counts.brand_id
            SET b.work_count = wb_counts.count
        ";
        $pdo->exec($sqlBrand);

        // 作品がないブランドの work_count を 0 にリセット
        $sqlBrandReset = "
            UPDATE brands 
            SET work_count = 0
            WHERE id NOT IN (SELECT DISTINCT brand_id FROM work_brands);
        ";
        $pdo->exec($sqlBrandReset);


        // ----------------------------------------------------------------------
        // 2. タグ (tags) カウントの再計算
        // ----------------------------------------------------------------------
        $sqlTag = "
            UPDATE tags t
            JOIN (
                SELECT tag_id, COUNT(work_id) AS count
                FROM work_tags
                GROUP BY tag_id
            ) AS wt_counts
            ON t.id = wt_counts.tag_id
            SET t.work_count = wt_counts.count
        ";
        $pdo->exec($sqlTag);

        // 作品がないタグの work_count を 0 にリセット
        $sqlTagReset = "
            UPDATE tags 
            SET work_count = 0
            WHERE id NOT IN (SELECT DISTINCT tag_id FROM work_tags);
        ";
        $pdo->exec($sqlTagReset);


        // ----------------------------------------------------------------------
        // 3. 女優 (actors) カウントの再計算
        // ----------------------------------------------------------------------
        $sqlActor = "
            UPDATE actors a
            JOIN (
                SELECT actor_id, COUNT(work_id) AS count
                FROM work_actors
                GROUP BY actor_id
            ) AS wa_counts
            ON a.id = wa_counts.actor_id
            SET a.work_count = wa_counts.count
        ";
        $pdo->exec($sqlActor);

        // 作品がない女優の work_count を 0 にリセット
        $sqlActorReset = "
            UPDATE actors 
            SET work_count = 0
            WHERE id NOT IN (SELECT DISTINCT actor_id FROM work_actors);
        ";
        $pdo->exec($sqlActorReset);
    }

    /**
     * レーベル (labels) の work_count を再計算し更新する
     */
    public function recalculateLabelCounts(): void
    {
        $pdo = Database::getConnection();
        // ----------------------------------------------------------------------
        // レーベル (labels) カウントの再計算
        // ----------------------------------------------------------------------
        $sqlLabel = "
            UPDATE labels l
            JOIN (
                SELECT label_id, COUNT(work_id) as count
                FROM work_labels
                GROUP BY label_id
            ) AS wl_counts
            ON l.id = wl_counts.label_id
            SET l.work_count = wl_counts.count
        ";
        $pdo->exec($sqlLabel);

        // 作品がないレーベルの work_count を 0 にリセット
        $sqlLabelReset = "
            UPDATE labels 
            SET work_count = 0
            WHERE id NOT IN (SELECT DISTINCT label_id FROM work_labels);
        ";
        $pdo->exec($sqlLabelReset);
    }


    /**
     * ブランド (brands) の work_count を再計算し更新する
     */
    public function recalculateBrandCounts(): void
    {
        $pdo = Database::getConnection();
        // ----------------------------------------------------------------------
        // ブランド (brands) カウントの再計算
        // ----------------------------------------------------------------------
        $sqlBrand = "
            UPDATE brands b
            JOIN (
                SELECT brand_id, COUNT(work_id) as count
                FROM work_brands
                GROUP BY brand_id
            ) AS wb_counts
            ON b.id = wb_counts.brand_id
            SET b.work_count = wb_counts.count
        ";
        $pdo->exec($sqlBrand);

        // 作品がないブランドの work_count を 0 にリセット
        $sqlBrandReset = "
            UPDATE brands 
            SET work_count = 0
            WHERE id NOT IN (SELECT DISTINCT brand_id FROM work_brands);
        ";
        $pdo->exec($sqlBrandReset);
    }

    /**
     * シリーズ (series) の work_count を再計算し更新する
     */
    public function recalculateSeriesCounts(): void
    {
        $pdo = Database::getConnection();
        // ----------------------------------------------------------------------
        // シリーズ (series) カウントの再計算
        // ----------------------------------------------------------------------
        $sqlSeries = "
            UPDATE series s
            JOIN (
                SELECT series_id, COUNT(work_id) AS count
                FROM work_series
                GROUP BY series_id
            ) AS ws_counts
            ON s.id = ws_counts.series_id
            SET s.work_count = ws_counts.count
        ";
        $pdo->exec($sqlSeries);

        // 作品がないシリーズの work_count を 0 にリセット
        $sqlSeriesReset = "
            UPDATE series 
            SET work_count = 0
            WHERE id NOT IN (SELECT DISTINCT series_id FROM work_series);
        ";
        $pdo->exec($sqlSeriesReset);
    }

    /**
     * 主要なテーブルのレコード数を取得する
     * @return array テーブル名とカウントの連想配列
     */
    public function getTableCounts(): array
    {
        // WorksModel.php は App\Core\Database を use していることを前提とします
        $pdo = \App\Core\Database::getConnection();
        $counts = [];
        $tables = [
            'works',
            'actors',
            'tags',
            'brands',
            'series',
            'labels',
            'work_actors',
            'work_tags',
            'work_labels',
            'work_brands',
            'work_series',
            'work_captures'
        ];

        foreach ($tables as $table) {
            try {
                // バッククォートを使用してテーブル名を保護
                $stmt = $pdo->query("SELECT COUNT(*) FROM `{$table}`");
                $counts[$table] = (int)$stmt->fetchColumn();
            } catch (\PDOException $e) {
                // テーブルが存在しない、またはアクセスエラーの場合
                $counts[$table] = "ERROR: " . $e->getMessage();
            }
        }
        return $counts;
    }

    /**
     * 特定のサイトIDとブランド名に紐づく作品リストを取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $brandName ブランド名
     * @param int $perPage 1ページあたりの件数
     * @param int $offset オフセット
     * @return array 作品データの配列
     */
    public function getWorksByBrand(
        string $siteId,
        string $brandName,
        int $perPage,
        int $offset
    ): array {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得

            // 1. WHERE句とパラメータの準備
            $where = "b.name COLLATE utf8mb4_general_ci = :brand_name";
            $params = [
                ':brand_name' => $brandName, 
                ':limit' => $perPage, 
                ':offset' => $offset,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];

            // ★ 修正済み: site_idによる絞り込みを常に適用 (サイトID 'all' の処理を排除)
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";

            // 2. クエリの構築
            $sql = "
                SELECT 
                    w.*,
                    GROUP_CONCAT(DISTINCT a.name) AS actor_names,
                    b.name AS brand_name
                FROM 
                    works w
                INNER JOIN
                    work_brands wb ON w.work_id COLLATE utf8mb4_general_ci = wb.work_id AND w.site_id COLLATE utf8mb4_general_ci = wb.site_id
                INNER JOIN
                    brands b ON wb.brand_id = b.id
                LEFT JOIN
                    work_actors wa ON w.work_id COLLATE utf8mb4_general_ci = wa.work_id
                LEFT JOIN
                    actors a ON wa.actor_id = a.id
                WHERE 
                    {$where}
                GROUP BY 
                    w.work_id, w.site_id
                ORDER BY 
                    w.release_date DESC, w.id DESC
                LIMIT :limit 
                OFFSET :offset;
            ";

            // 3. プリペアドステートメントの準備とバインド
            $stmt = $pdo->prepare($sql);

            foreach ($params as $key => &$val) {
                if ($key === ':limit' || $key === ':offset') {
                    // LIMIT/OFFSETは整数としてバインド
                    $stmt->bindValue($key, $val, \PDO::PARAM_INT);
                } else {
                    // その他は文字列としてバインド
                    $stmt->bindValue($key, $val, \PDO::PARAM_STR);
                }
            }

            // クエリの実行
            $stmt->execute();
            return $stmt->fetchAll(\PDO::FETCH_ASSOC);
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getWorksByBrand): " . $e->getMessage());
            return [];
        }
    }

    /**
     * 特定のサイトIDとレーベル名に紐づく作品リストを取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $labelName レーベル名
     * @param int $perPage 1ページあたりの件数
     * @param int $offset オフセット
     * @return array 作品データの配列
     */
    public function getWorksByLabel(
        string $siteId,
        string $labelName,
        int $perPage,
        int $offset
    ): array {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "l.name COLLATE utf8mb4_general_ci = :label_name";
            $params = [
                ':label_name' => $labelName, 
                ':limit' => $perPage, 
                ':offset' => $offset,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";
            
            // 2. クエリの構築
            $sql = "
                SELECT 
                    w.*,
                    GROUP_CONCAT(DISTINCT a.name) AS actor_names,
                    b.name AS brand_name
                FROM 
                    works w
                INNER JOIN 
                    work_labels wl ON w.work_id COLLATE utf8mb4_general_ci = wl.work_id
                INNER JOIN 
                    labels l ON wl.label_id = l.id
                LEFT JOIN
                    work_actors wa ON w.work_id COLLATE utf8mb4_general_ci = wa.work_id
                LEFT JOIN
                    actors a ON wa.actor_id = a.id
                LEFT JOIN
                    work_brands wb ON w.work_id COLLATE utf8mb4_general_ci = wb.work_id AND w.site_id COLLATE utf8mb4_general_ci = wb.site_id
                LEFT JOIN
                    brands b ON wb.brand_id = b.id
                WHERE 
                    {$where}
                GROUP BY 
                    w.work_id, w.site_id
                ORDER BY 
                    w.release_date DESC, w.id DESC
                LIMIT :limit 
                OFFSET :offset;
            ";

            // 3. プリペアドステートメントの準備とバインド
            $stmt = $pdo->prepare($sql);

            foreach ($params as $key => &$val) {
                if ($key === ':limit' || $key === ':offset') {
                    $stmt->bindValue($key, $val, \PDO::PARAM_INT);
                } else {
                    $stmt->bindValue($key, $val, \PDO::PARAM_STR);
                }
            }
            
            // クエリの実行
            $stmt->execute();
            return $stmt->fetchAll(\PDO::FETCH_ASSOC);
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getWorksByLabel): " . $e->getMessage());
            return [];
        }
    }

    /**
     * 特定のレーベルに紐づく総作品数を取得する
     * @param string $siteId 現在のサイトID ('okashi', 'lemon', 'b10f')
     * @param string $labelName レーベル名
     * @return int 総作品数
     */
    public function getTotalWorksCountByLabel(string $siteId, string $labelName): int
    {
        try {
            $pdo = \App\Core\Database::getConnection(); // データベース接続の取得
            
            // 1. WHERE句とパラメータの準備
            $where = "l.name COLLATE utf8mb4_general_ci = :label_name";
            $params = [
                ':label_name' => $labelName,
                ':site_id' => $siteId // 常にサイトIDを含める
            ];
            
            // ★ 修正済み: site_idによる絞り込みを常に適用
            $where .= " AND w.site_id COLLATE utf8mb4_general_ci = :site_id";

            // 2. クエリの構築
            $sql = "
                SELECT 
                    COUNT(DISTINCT w.work_id) 
                FROM 
                    works w
                JOIN 
                    work_labels wl ON w.work_id COLLATE utf8mb4_general_ci = wl.work_id
                JOIN
                    labels l ON wl.label_id = l.id
                WHERE 
                    {$where}
            ";
            
            // 3. プリペアドステートメントの準備と実行
            $stmt = $pdo->prepare($sql);
            
            // パラメータのバインド
            foreach ($params as $key => &$val) {
                 $stmt->bindValue($key, $val, \PDO::PARAM_STR);
            }
            
            // クエリの実行
            $stmt->execute();
            return (int)$stmt->fetchColumn();
        } catch (\PDOException $e) {
            error_log("WorksModel DB Error (getTotalWorksCountByLabel): " . $e->getMessage());
            return 0;
        }
    }
}


--- FILE: ./app/Models/TagModel.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/models/TagModel.php

namespace App\Models;

use App\Core\Database; // ご提示いただいたDatabaseクラスを利用
use PDO;
use PDOException;

class TagModel
{
    /**
     * 特定のサイトIDとタグ名に一致するタグの情報をデータベースから取得する
     *
     * @param string $siteId 対象のサイトID (例: 'lemon', 'okashi', 'all')
     * @param string $tagName 対象のタグ名 (デコード済み)
     * @return array|null タグ情報の配列 (PDO::FETCH_ASSOC)、または見つからなかった場合はnull
     */
    public function findBySiteIdAndName(string $siteId, string $tagName): ?array
    {
        try {
            $pdo = Database::getConnection();
            $params = [':tag_name' => $tagName];
            
            // ★修正: タグ名比較に COLLATE を適用
            $tagNameWhere = "name COLLATE utf8mb4_general_ci = :tag_name";

            if ($siteId === 'all') {
                $sql = "
                    SELECT 
                        id, 
                        name,
                        work_count, 
                        'all' AS site_id 
                    FROM 
                        tags 
                    WHERE 
                        {$tagNameWhere}
                    LIMIT 1;
                ";
            } else {
                // 特定サイトの場合: tag_sites テーブルをJOINして検索
                $params[':site_id'] = $siteId;
                
                // ★修正: サイトID比較に COLLATE を適用
                $siteIdWhere = "ts.site_id COLLATE utf8mb4_general_ci = :site_id";

                $sql = "
                    SELECT 
                        t.id, 
                        t.name, 
                        ts.site_id, 
                        ts.work_count
                    FROM 
                        tags t
                    INNER JOIN
                        tag_sites ts ON t.id = ts.tag_id
                    WHERE 
                        {$siteIdWhere} AND t.{$tagNameWhere}
                    LIMIT 1;
                ";
            }

            $stmt = $pdo->prepare($sql);
            
            // パラメータをバインド
            foreach ($params as $key => &$val) {
                 $stmt->bindParam($key, $val, PDO::PARAM_STR);
            }
            
            $stmt->execute();
            $tagInfo = $stmt->fetch(PDO::FETCH_ASSOC);

            return $tagInfo ?: null;
        } catch (PDOException $e) {
            error_log("TagModel DB Error (findBySiteIdAndName): " . $e->getMessage());
            return null;
        }
    }

    /**
     * 特定の作品IDに紐づく全てのタグ名を取得する
     *
     * @param string $workId 対象の作品ID (例: 'ABC-123')
     * @return array タグ名の配列 (例: ['ビキニ', '巨乳', 'コスプレ'])
     */
    public function getTagsByWorkId(string $workId): array
    {
        try {
            $pdo = Database::getConnection();

            // ★修正: JOIN条件とWHERE条件に COLLATE を適用
            $sql = "
                SELECT 
                    t.name
                FROM 
                    tags t
                INNER JOIN 
                    work_tags wt ON t.id = wt.tag_id
                INNER JOIN 
                    works w ON w.work_id COLLATE utf8mb4_general_ci = wt.work_id  /* work_idの結合に適用 */
                WHERE 
                    w.work_id COLLATE utf8mb4_general_ci = :workId  /* work_idの比較に適用 */
                ORDER BY 
                    t.name ASC; 
            ";
            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':workId', $workId, PDO::PARAM_STR);
            $stmt->execute();
            
            // FETCH_COLUMNでタグ名のみの配列を取得
            return $stmt->fetchAll(PDO::FETCH_COLUMN, 0); 

        } catch (PDOException $e) {
            error_log("TagModel DB Error (getTagsByWorkId): " . $e->getMessage());
            return []; // エラー時は空の配列を返す
        }
    }
}

--- FILE: ./app/Models/SeriesModel.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/models/SeriesModel.php

namespace App\Models;

use App\Core\Database;
use PDO;
use PDOException;

class SeriesModel
{
    /**
     * 特定のサイトIDとシリーズ名に一致するシリーズ情報を取得する
     *
     * @param string $siteId 対象のサイトID
     * @param string $seriesName 対象のシリーズ名 (デコード済み)
     * @return array|null シリーズ情報の配列、または見つからなかった場合はnull
     */
    public function findBySiteIdAndName(string $siteId, string $seriesName): ?array
    {
        try {
            $pdo = Database::getConnection(); 
            
            // 照合順序を統一したため、シンプルでクリーンなSQLが利用可能
            $sql = "
                SELECT 
                    s.id, 
                    s.name, 
                    s.work_count, 
                    ss.site_id
                FROM 
                    series s
                INNER JOIN
                    series_sites ss ON s.id = ss.series_id 
                WHERE 
                    ss.site_id = :site_id AND s.name = :series_name
                LIMIT 1;
            ";

            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':site_id', $siteId, PDO::PARAM_STR);
            $stmt->bindParam(':series_name', $seriesName, PDO::PARAM_STR);
            $stmt->execute();
            $seriesInfo = $stmt->fetch(PDO::FETCH_ASSOC);

            return $seriesInfo ?: null;

        } catch (PDOException $e) {
            // エラーロギングとnull返却
            error_log("SeriesModel DB Error: " . $e->getMessage());
            return null; 
        }
    }

    /**
     * 特定の作品IDに紐づくシリーズ名を取得する
     * * シリーズが紐づいていない場合はnullを返す。
     *
     * @param string $workId 対象の作品ID (例: 'ABC-123')
     * @return string|null シリーズ名、または見つからなかった場合はnull
     */
    public function getSeriesNameByWorkId(string $workId): ?string
    {
        try {
            $pdo = Database::getConnection();

            $sql = "
                SELECT 
                    s.name
                FROM 
                    series s
                INNER JOIN 
                    work_series ws ON s.id = ws.series_id
                WHERE 
                    ws.work_id = :workId
                LIMIT 1;
            ";
            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':workId', $workId, PDO::PARAM_STR);
            $stmt->execute();
            
            // 単一のカラム（シリーズ名）を文字列として取得
            $seriesName = $stmt->fetchColumn(); 

            // 結果が false (見つからなかった場合) の場合は null を返す
            return $seriesName !== false ? $seriesName : null;

        } catch (PDOException $e) {
            error_log("SeriesModel DB Error (getSeriesNameByWorkId): " . $e->getMessage());
            return null; // エラー時は null を返す
        }
    }
}

--- FILE: ./app/Models/ActorModel.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/app/models/ActorModel.php

namespace App\Models;

use App\Core\Database;
use PDO;
use PDOException;

class ActorModel
{
    /**
     * 特定のサイトIDとアクター名に一致するアクター情報を取得する
     *
     * @param string $siteId 対象のサイトID
     * @param string $actorName 対象のアクター名 (デコード済み)
     * @return array|null アクター情報の配列、または見つからなかった場合はnull
     */
    public function findBySiteIdAndName(string $siteId, string $actorName): ?array
    {
        try {
            $pdo = Database::getConnection(); 
            
            $sql = "
                SELECT 
                    a.id, 
                    a.name, 
                    a.work_count, 
                    aa.site_id
                FROM 
                    actors a
                INNER JOIN
                    actor_sites aa ON a.id = aa.actor_id 
                WHERE 
                    aa.site_id = :site_id AND a.name = :actor_name
                LIMIT 1;
            ";

            $stmt = $pdo->prepare($sql);
            $stmt->bindParam(':site_id', $siteId, PDO::PARAM_STR);
            $stmt->bindParam(':actor_name', $actorName, PDO::PARAM_STR);
            $stmt->execute();
            $actorInfo = $stmt->fetch(PDO::FETCH_ASSOC);

            return $actorInfo ?: null;

        } catch (PDOException $e) {
            error_log("ActorModel DB Error: " . $e->getMessage());
            return null; 
        }
    }
}

--- FILE: ./app/Models/NavModel.php ---

<?php
namespace App\Models;

use App\Core\Database;

class NavModel
{
    private \PDO $pdo;
    private const SIDEBAR_LIMIT = 20;

    public function __construct()
    {
        $this->pdo = Database::getConnection(); 
    }
    
    // ----------------------------------------------------
    // サイト別クエリ生成ロジック
    // ----------------------------------------------------

    /**
     * 俳優を作品数の多い順に取得する
     */
    public function getActors(string $siteId): array
    {
        $sql = "
            SELECT 
                m.name, 
                COUNT(wa.work_id) AS work_count
            FROM 
                actors m
            JOIN
                work_actors wa ON m.id = wa.actor_id
            JOIN
                works w ON wa.work_id = w.work_id
            WHERE 
                w.site_id = :siteId 
            GROUP BY 
                m.id, m.name
            ORDER BY 
                work_count DESC, m.name ASC
            LIMIT 
                :limit
        ";
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':limit', self::SIDEBAR_LIMIT, \PDO::PARAM_INT);
        $stmt->bindValue(':siteId', $siteId, \PDO::PARAM_STR); 
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }
    
    /**
     * タグを作品数の多い順に取得する
     */
    public function getTags(string $siteId): array
    {
        $sql = "
            SELECT 
                m.name, 
                COUNT(wt.work_id) AS work_count
            FROM 
                tags m
            JOIN
                work_tags wt ON m.id = wt.tag_id
            JOIN
                works w ON wt.work_id = w.work_id
            WHERE 
                w.site_id = :siteId 
            GROUP BY 
                m.id, m.name
            ORDER BY 
                work_count DESC, m.name ASC
            LIMIT 
                :limit
        ";
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':limit', self::SIDEBAR_LIMIT, \PDO::PARAM_INT);
        $stmt->bindValue(':siteId', $siteId, \PDO::PARAM_STR); 
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * シリーズを作品数の多い順に取得する
     */
    public function getSeries(string $siteId): array
    {
        $sql = "
            SELECT 
                m.name, 
                COUNT(ws.work_id) AS work_count
            FROM 
                series m
            JOIN
                work_series ws ON m.id = ws.series_id
            JOIN
                works w ON ws.work_id = w.work_id
            WHERE 
                w.site_id = :siteId
            GROUP BY 
                m.id, m.name
            ORDER BY 
                work_count DESC, m.name ASC
            LIMIT 
                :limit
        ";
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':limit', self::SIDEBAR_LIMIT, \PDO::PARAM_INT);
        $stmt->bindValue(':siteId', $siteId, \PDO::PARAM_STR); 
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * メーカー/ブランドを作品数の多い順に取得する
     */
    public function getBrands(string $siteId): array
    {
        $sql = "
            SELECT 
                m.name, 
                COUNT(wm.work_id) AS work_count
            FROM 
                brands m
            JOIN
                work_brands wm ON m.id = wm.brand_id
            JOIN
                works w ON wm.work_id = w.work_id
            WHERE 
                w.site_id = :siteId
            GROUP BY 
                m.id, m.name
            ORDER BY 
                work_count DESC, m.name ASC
            LIMIT 
                :limit
        ";
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':limit', self::SIDEBAR_LIMIT, \PDO::PARAM_INT);
        $stmt->bindValue(':siteId', $siteId, \PDO::PARAM_STR); 
        $stmt->execute();
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }

    /**
     * レーベルを作品数の多い順に取得する
     */
    public function getLabels(string $siteId): array
    {
        $sql = "
            SELECT 
                m.name, 
                COUNT(wl.work_id) AS work_count
            FROM 
                labels m
            JOIN
                work_labels wl ON m.id = wl.label_id
            JOIN
                works w ON wl.work_id = w.work_id
            WHERE 
                w.site_id = :siteId
            GROUP BY 
                m.id, m.name
            ORDER BY 
                work_count DESC, m.name ASC
            LIMIT 
                :limit
        ";
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':limit', self::SIDEBAR_LIMIT, \PDO::PARAM_INT);
        $stmt->bindValue(':siteId', $siteId, \PDO::PARAM_STR); 
        $stmt->execute();
        
        return $stmt->fetchAll(\PDO::FETCH_ASSOC);
    }
}

--- FILE: ./index.php ---

<?php
// /home/wp552476/avflash.xyz/public_html/index.php (修正版)

// ------------------------------------
// 0. Composer Autoloadの読み込み (必須)
// ------------------------------------
require __DIR__ . '/vendor/autoload.php';

// ------------------------------------
// 1. 初期設定と環境設定
// ------------------------------------
global $config;
$config = require_once __DIR__ . '/config.php'; 

// ★★★ 修正箇所: 手動でコアクラスを読み込む ★★★
require_once __DIR__ . '/app/Core/Database.php';   
require_once __DIR__ . '/app/Core/Router.php';      
// ★★★ --------------------------------------- ★★★


// ヘルパーの読み込み
require_once __DIR__ . '/app/helpers.php'; 

// クラスの利用宣言
use App\Core\Database;
use App\Core\Router;

// デバッグ設定
if (config('app.debug') === true) {
    ini_set('display_errors', 1);
    error_reporting(E_ALL);
} else {
    ini_set('display_errors', 0);
    error_reporting(E_ALL);
}

// ------------------------------------
// 2. DB接続の準備 (データ処理のために必須)
// ------------------------------------
Database::loadConfig($config); 

// Routerインスタンスの作成
$router = new Router();

// ------------------------------------
// 3. ルーティング定義の読み込みと実行
// ------------------------------------
require_once __DIR__ . '/web.php';

$uri = $_SERVER['REQUEST_URI'];
// ★ 修正: Router::findRoute() は [Controller, Method, [Args...]] の形式を返す
$routeData = Router::findRoute($uri); 

if (!$routeData) {
    http_response_code(404);
    \dd("404 Not Found: Could not find route for URI '{$uri}'"); 
}

// 4. コントローラーとアクションの実行 (引数対応)
// [0]: ControllerName, [1]: MethodName, [2]: Arguments Array
list($controllerName, $methodName, $args) = $routeData; // ★ 修正: $args (引数配列) を抽出

$controllerClass = 'App\\Controllers\\' . $controllerName; 

if (class_exists($controllerClass)) {
    $controller = new $controllerClass();
    
    if (method_exists($controller, $methodName)) {
        // ★ 修正: call_user_func_array を使用して引数を渡す
        // HomeController::index($siteId) や CategoryController::show($siteId, $categoryName) に対応
        call_user_func_array([$controller, $methodName], $args); 
        
    } else {
        \dd("500 Server Error: Method '{$methodName}' not found in '{$controllerClass}'.");
    }
} else {
    \dd("500 Server Error: Controller '{$controllerClass}' not found. Check filename/namespace.");
}

--- FILE: ./views/layouts/app.php ---

<!DOCTYPE html>
<html lang="ja">

<?php 
// HEADを読み込む
require __DIR__ . '/_head.php'; 
?>

<body>

<?php 
// TOPを読み込む
require __DIR__ . '/_top.php'; 
?>

<div class="container">
    
    <nav aria-label="breadcrumb" class="mb-3">
      <ol class="breadcrumb bg-dark p-2 rounded small"> 
        <li class="breadcrumb-item"><a href="<?php echo config('app.base_url'); ?>" class="text-emphasis"><i class="fas fa-home"></i> ホーム</a></li>
        <li class="breadcrumb-item active text-white" aria-current="page"><?php echo htmlspecialchars($page_title ?? 'コンテンツ'); ?></li>
      </ol>
    </nav>

    <div class="row">
        
        <div class="col-lg-3 d-none d-lg-block">
            <?php require __DIR__ . '/_sidebar.php'; ?>
        </div>

        <div class="col-lg-9">
            <main class="main-content-card"> <h2 class="border-bottom border-danger pb-2 mb-4 text-emphasis"><?php echo htmlspecialchars($page_title ?? 'コンテンツ'); ?></h2>
                
                <?php 
                if (isset($content)) {
                    echo $content; 
                }
                ?>
            </main>
        </div>
        
    </div>
</div>

<?php 
// FOOTERを読み込む
require __DIR__ . '/_footer.php'; 
?>

</html>

--- FILE: ./views/layouts/_head.php ---

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="<?php echo htmlspecialchars($description ?? 'アダルト動画作品の最新情報と作品リスト。自作MVCモデルで構築された高速なサイトです。'); ?>">
    <meta name="keywords" content="アダルト, AV, 最新作品, 動画, <?php echo htmlspecialchars($keywords ?? 'av, works'); ?>">
    <meta name="author" content="<?php echo config('app.name'); ?>">
    
    <title><?php echo htmlspecialchars($title ?? config('app.name')); ?> | <?php echo config('app.name'); ?></title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    
    <link rel="stylesheet" href="<?php echo config('app.base_url'); ?>assets/css/styles.css">

</head>

--- FILE: ./views/layouts/_top.php ---

<nav class="navbar navbar-expand-lg navbar-dark bg-dark mb-4 border-bottom border-danger navbar-compact">
    <div class="container-fluid">
        <a class="navbar-brand text-emphasis" href="<?php echo config('app.base_url'); ?>">
            <i class="fas fa-video me-2"></i> <?php echo config('app.name'); ?>
        </a>
        <div class="d-flex">
            <?php if (isset($is_logged_in) && $is_logged_in): ?>
                <span class="navbar-text me-3 text-white-50">ようこそ、ユーザー名さん</span>
                <a href="/logout" class="btn btn-sm btn-outline-danger"><i class="fas fa-sign-out-alt"></i> ログアウト</a>
            <?php else: ?>
                <form class="d-flex align-items-center login-form-compact" action="/login" method="POST">
                    <input class="form-control form-control-sm me-1" type="email" placeholder="メール" aria-label="Email" name="email">
                    <input class="form-control form-control-sm me-1" type="password" placeholder="パスワード" aria-label="Password" name="password">
                    <button class="btn btn-sm btn-danger" type="submit"><i class="fas fa-lock"></i> ログイン</button>
                </form>
            <?php endif; ?>
        </div>
    </div>
</nav>

--- FILE: ./views/layouts/_sidebar.php ---

<?php
/**
 * ファイル名: sidebar_integrated.php
 * 想定されるデータ: 
 * $sidebarData = [...]; 
 * $sidebarMeta = [ 'sidebarTitle' => '...', 'staticCategories' => [...] ];
 * $siteId: コントローラから渡された現在のサイトID ('lemon', 'okashi', 'b10f')
 */

// ★★★ 修正済み: 変数の安全装置を追加し、未定義エラーを防止する ★★★
$siteId = $siteId ?? null;
$sidebarData = $sidebarData ?? []; // ★ 追加: $sidebarDataが未定義の場合、空配列で初期化
$sidebarMeta = $sidebarMeta ?? []; // ★ 追加: $sidebarMetaが未定義の場合、空配列で初期化

// $siteId が未定義の場合、'okashi'を安全なデフォルトとする
$currentSiteId = $siteId ?? 'okashi'; 

// NavControllerから渡された $sidebarMeta の値を使用し、ローカル変数を定義
$sidebarTitle = $sidebarMeta['sidebarTitle'] ?? '人気コンテンツ';
$staticCategories = $sidebarMeta['staticCategories'] ?? [];

// URLパス生成ロジック
$sitePathPrefix = '/' . htmlspecialchars($currentSiteId);
?>

<div class="sidebar p-3 bg-white border rounded shadow-sm">

    <h5 class="py-2 border-bottom mb-3 text-primary">
        <i class="fas fa-bars me-2"></i><?= htmlspecialchars($sidebarTitle) ?>
    </h5>

    <div class="sidebar-section mb-4">
        <h6 class="text-secondary fw-bold mb-2"><i class="fas fa-layer-group me-1"></i>サイト切り替え</h6>
        <ul class="nav flex-column mb-3">
            
            <li class="nav-item">
                <a class="nav-link text-dark ps-0 py-1 <?= ($currentSiteId === 'lemon') ? 'active fw-bold text-warning' : ''; ?>" 
                    href="/lemon">
                    <i class="fas fa-lemon me-2 text-warning"></i>LEMON（レモン）
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link text-dark ps-0 py-1 <?= ($currentSiteId === 'okashi') ? 'active fw-bold text-danger' : ''; ?>" 
                    href="/okashi">
                    <i class="fas fa-candy-cane me-2 text-danger"></i>OKASHI（お菓子）
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link text-dark ps-0 py-1 <?= ($currentSiteId === 'b10f') ? 'active fw-bold text-info' : ''; ?>" 
                    href="/b10f">
                    <i class="fas fa-building me-2 text-info"></i>B10F（地下１０階）
                </a>
            </li>
            <hr class="my-2 w-75">
            
            <h6 class="text-secondary fw-bold mt-3 mb-2"><i class="fas fa-list me-1"></i>ジャンル別ナビ</h6>
            
            <li class="nav-item"><a class="nav-link text-dark ps-0 py-1" href="<?= $sitePathPrefix ?>/category/new"><i class="fas fa-fire me-2 text-danger"></i>最新作品</a></li>
            <li class="nav-item"><a class="nav-link text-dark ps-0 py-1" href="<?= $sitePathPrefix ?>/category/ranking"><i class="fas fa-star me-2 text-warning"></i>人気ランキング</a></li>
            
            <?php foreach ($staticCategories as $cat): ?>
                <li class="nav-item">
                    <a class="nav-link text-dark ps-0 py-1" href="<?= htmlspecialchars($cat['href']) ?>">
                        <i class="<?= htmlspecialchars($cat['icon']) ?> me-2 text-info"></i><?= htmlspecialchars($cat['name']) ?>
                    </a>
                </li>
            <?php endforeach; ?>
        </ul>
    </div>

    <hr class="my-3">

    <div class="sidebar-section mb-4">
        <h6 class="text-secondary fw-bold mb-3"><i class="fas fa-industry me-1"></i>人気メーカー（ブランド）</h6>
        <?php if (!empty($sidebarData['brands'])): ?>
            <ul class="list-group list-group-flush manufacturer-list small">
                <?php foreach ($sidebarData['brands'] as $brand): ?>
                    <li class="list-group-item d-flex justify-content-between align-items-center px-0 py-1">
                        <a href="<?= $sitePathPrefix ?>/brand/<?= urlencode($brand['name']) ?>" class="text-dark text-decoration-none">
                            <?= htmlspecialchars($brand['name']) ?>
                        </a>
                        <span class="badge bg-secondary-subtle text-secondary">
                            <?= number_format($brand['work_count']) ?>
                        </span>
                    </li>
                <?php endforeach; ?>
            </ul>
        <?php else: ?>
            <p class="text-muted small">関連するメーカーはありません。</p>
        <?php endif; ?>
    </div>

    <hr class="my-3">

    <div class="sidebar-section mb-4">
        <h6 class="text-secondary fw-bold mb-3"><i class="fas fa-bookmark me-1"></i>人気レーベル</h6>
        <?php if (!empty($sidebarData['labels'])): ?>
            <ul class="list-group list-group-flush label-list small">
                <?php foreach ($sidebarData['labels'] as $label): ?>
                    <li class="list-group-item d-flex justify-content-between align-items-center px-0 py-1">
                        <a href="<?= $sitePathPrefix ?>/label/<?= urlencode($label['name']) ?>" class="text-dark text-decoration-none">
                            <?= htmlspecialchars($label['name']) ?>
                        </a>
                        <span class="badge bg-secondary-subtle text-secondary">
                            <?= number_format($label['work_count']) ?>
                        </span>
                    </li>
                <?php endforeach; ?>
            </ul>
        <?php else: ?>
            <p class="text-muted small">関連するレーベルはありません。</p>
        <?php endif; ?>
    </div>

    <hr class="my-3">

    <div class="sidebar-section mb-4">
        <h6 class="text-secondary fw-bold mb-3"><i class="fas fa-tags me-1"></i>人気タグ</h6>
        <?php if (!empty($sidebarData['tags'])): ?>
            <div class="d-flex flex-wrap tag-list">
                <?php foreach ($sidebarData['tags'] as $tag): ?>
                    <a href="<?= $sitePathPrefix ?>/tag/<?= urlencode($tag['name']) ?>"
                        class="badge text-decoration-none p-1 px-2 m-1 bg-light text-dark border small">
                        <?= htmlspecialchars($tag['name']) ?>
                        <span class="text-muted">(<?= number_format($tag['work_count']) ?>)</span>
                    </a>
                <?php endforeach; ?>
            </div>
        <?php else: ?>
            <p class="text-muted small">関連するタグはありません。</p>
        <?php endif; ?>
    </div>

    <hr class="my-3">

    <div class="sidebar-section mb-4">
        <h6 class="text-secondary fw-bold mb-3"><i class="fas fa-video me-1"></i>人気シリーズ</h6>
        <?php if (!empty($sidebarData['series'])): ?>
            <ul class="list-group list-group-flush series-list small">
                <?php foreach ($sidebarData['series'] as $series): ?>
                    <li class="list-group-item d-flex justify-content-between align-items-center px-0 py-1">
                        <a href="<?= $sitePathPrefix ?>/series/<?= urlencode($series['name']) ?>" class="text-dark text-decoration-none">
                            <?= htmlspecialchars($series['name']) ?>
                        </a>
                        <span class="badge bg-secondary-subtle text-secondary">
                            <?= number_format($series['work_count']) ?>
                        </span>
                    </li>
                <?php endforeach; ?>
            </ul>
        <?php else: ?>
            <p class="text-muted small">関連するシリーズはありません。</p>
        <?php endif; ?>
    </div>

    <hr class="my-3">

    <div class="sidebar-section mb-4">
        <h6 class="text-secondary fw-bold mb-3"><i class="fas fa-user-tag me-1"></i>人気の出演者</h6>
        <?php if (!empty($sidebarData['actors'])): ?>
            <ul class="list-group list-group-flush actor-list small">
                <?php foreach ($sidebarData['actors'] as $actor): ?>
                    <li class="list-group-item d-flex justify-content-between align-items-center px-0 py-1">
                        <a href="<?= $sitePathPrefix ?>/actor/<?= urlencode($actor['name']) ?>" class="text-dark text-decoration-none">
                            <?= htmlspecialchars($actor['name']) ?>
                        </a>
                        <span class="badge bg-secondary-subtle text-secondary">
                            <?= number_format($actor['work_count']) ?>
                        </span>
                    </li>
                <?php endforeach; ?>
            </ul>
        <?php else: ?>
            <p class="text-muted small">関連する出演者はいません。</p>
        <?php endif; ?>
    </div>

    <hr class="my-3">
    <div class="sidebar-section">
        <h6 class="text-secondary fw-bold mb-3"><i class="fas fa-link me-1"></i>関連リンク</h6>
        <p class="small text-muted border p-2 bg-light">ここにASP広告や重要な内部リンクを配置します。</p>
    </div>
</div>

--- FILE: ./views/layouts/_footer.php ---

<footer class="mt-5 pt-3 border-top border-secondary bg-dark">
    <div class="container">
        <div class="row">
            
            <div class="col-md-4 mb-4">
                <h5 class="text-emphasis"><i class="fas fa-video me-2"></i><?php echo config('app.name'); ?></h5>
                <p class="text-muted small">
                    自作MVCフレームワークによるデモサイトです。<br>
                    高速な作品情報提供を目指します。
                </p>
            </div>

            <div class="col-md-4 mb-4">
                <h5 class="text-white"><i class="fas fa-bars me-2"></i>ナビゲーション</h5>
                <ul class="list-unstyled">
                    <li><a href="/" class="text-decoration-none text-muted"><i class="fas fa-home me-2"></i>ホーム</a></li>
                    <li><a href="/sitemap" class="text-decoration-none text-muted"><i class="fas fa-sitemap me-2"></i>サイトマップ</a></li>
                    <li><a href="/contact" class="text-decoration-none text-muted"><i class="fas fa-envelope me-2"></i>お問い合わせ</a></li>
                </ul>
            </div>

            <div class="col-md-4 mb-4">
                <h5 class="text-white"><i class="fas fa-gavel me-2"></i>法的情報</h5>
                <ul class="list-unstyled">
                    <li><a href="/privacy" class="text-decoration-none text-muted"><i class="fas fa-user-secret me-2"></i>プライバシーポリシー</a></li>
                    <li><a href="/terms" class="text-decoration-none text-muted"><i class="fas fa-file-contract me-2"></i>利用規約</a></li>
                    <li><a href="/disclaimer" class="text-decoration-none text-muted"><i class="fas fa-exclamation-triangle me-2"></i>免責事項</a></li>
                </ul>
            </div>
        </div>
        <div class="text-center py-3 border-top border-secondary">
            <p class="mb-0 small text-muted">&copy; 2025 <?php echo config('app.name'); ?>. Powered by <span class="text-emphasis">Custom MVC.</span></p>
        </div>
    </div>
</footer>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

--- FILE: ./views/works/index.php ---

<?php 
/**
 * テンプレートファイル: views/works/index.php
 * 変数 $works はコントローラーから view() ヘルパーを通して展開されています。
 */
?>
<div>
    <h3>作品リスト</h3>
    <?php if (empty($works)): ?>
        <p>現在、作品がありません。CSVファイル（/data/以下）と config.php のパス設定を確認してください。</p>
    <?php else: ?>
        <ul>
            <?php foreach ($works as $work): ?>
                <li>
                    <a href="<?php echo htmlspecialchars($work['商品URL']); ?>" target="_blank">
                        [<?php echo htmlspecialchars($work['商品ID']); ?>] 
                        <strong><?php echo htmlspecialchars($work['タイトル']); ?></strong>
                        (ブランド: <?php echo htmlspecialchars($work['ブランド']); ?> / 価格: <?php echo $work['レンタル視聴を含む最低価格[税込]']; ?>円)
                    </a>
                </li>
            <?php endforeach; ?>
        </ul>
    <?php endif; ?>
</div>

--- FILE: ./views/works/show.php ---

<?php 
// WorkControllerから渡されたデータ
$work = $data['work'];
$siteId = $data['siteId'];
$sidebarData = $data['sidebarData'];
dump($work);
?>

<div class="container mt-4">
    <div class="row">
        
        <div class="col-md-12">
            <h1 class="text-white mb-4"><?= htmlspecialchars($work['title'] ?? '作品タイトル') ?></h1>
            <div class="card bg-dark text-white border-secondary mb-4">
                <div class="row g-0">
                    <div class="col-md-4">
                        <img src="<?= htmlspecialchars($work['cover_url'] ?? '') ?>" class="img-fluid rounded-start" alt="<?= htmlspecialchars($work['title'] ?? '') ?>">
                    </div>
                    <div class="col-md-8">
                        <div class="card-body">
                            <p class="card-text small text-muted">作品ID: <?= htmlspecialchars($work['work_id'] ?? 'N/A') ?></p>
                            <p class="card-text small text-info">配信日: <?= htmlspecialchars(date('Y/m/d', strtotime($work['release_date'] ?? 'now'))) ?></p>
                            <hr class="border-secondary">
                            
                            <p><?= nl2br(htmlspecialchars($work['comment'] ?? '作品の概要がここに表示されます。')) ?></p>
                            
                            <div class="d-grid gap-2 mt-4">
                                <?= $work['link_title'] ?? '' ?> 
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <h2 class="text-white mb-3">作品イメージ</h2>
            <div class="row g-3 mb-5">
                <?php foreach (['capture_1_link', 'capture_2_link', 'capture_3_link'] as $key): ?>
                    <?php if (!empty($work[$key])): ?>
                    <div class="col-md-4">
                        <img src="<?= htmlspecialchars($work[$key]) ?>" class="img-fluid rounded shadow" alt="キャプチャ画像" loading="lazy">
                    </div>
                    <?php endif; ?>
                <?php endforeach; ?>
            </div>
            
        </div>
        

    </div>
</div>

--- FILE: ./views/home/index.php ---

<?php 
// データベースから取得した作品配列 $works が $data['works'] に格納されています。
$works = $data['works'];
$currentPage = $data['currentPage'];
$totalPages = $data['totalPages'];
// ★修正: HomeControllerから渡されるキー currentSiteId を使用し、変数名も currentSiteId に統一
$currentSiteId = $data['currentSiteId']; 
?>

<div class="container mt-4">
    <h1 class="text-white mb-4">最新作品一覧</h1>
    
    <div class="row row-cols-2 row-cols-sm-3 row-cols-md-4 row-cols-lg-5 g-3">
        <?php foreach ($works as $work): ?>
            <?php 
            // _work_card.php は $work 変数を必要とします
            require __DIR__ . '/../components/_work_card.php'; 
            ?>
            <?php endforeach; ?>
    </div>

    <?php 
    // _pagination.php は $currentPage, $totalPages, $currentSiteId を使用します
    require __DIR__ . '/../components/_pagination.php'; 
    ?>
</div>

--- FILE: ./views/components/_pagination.php ---

<?php
/**
 * ページネーションコンポーネント
 * 汎用性を高めるため、コントローラー側で以下の変数を view() 関数に渡す必要があります。
 * - $currentPage: 現在のページ番号 (必須)
 * - $totalPages: 総ページ数 (必須)
 * - $siteId または $currentSiteId: 現在のサイトID (例: 'lemon', 'all')
 * - $tagNameUrl, $actorNameUrl, etc.: ページネーション対象のエンティティ名 (例: タグ名)
 */

// ----------------------------------------------------------------------
// ★修正箇所: 変数の安全な初期化とパスの決定
// ----------------------------------------------------------------------

// コントローラーから渡される可能性のある変数名を統一して初期化
// $siteIdが渡されるケースが多いため、それを優先し、どちらもなければ空文字とする
$siteId = $siteId ?? $currentSiteId ?? '';
$tagNameUrl = $tagNameUrl ?? '';
$actorNameUrl = $actorNameUrl ?? '';
$manufacturerNameUrl = $manufacturerNameUrl ?? '';
$seriesNameUrl = $seriesNameUrl ?? '';

// ページングの基準となるベースルートを決定
if (!empty($tagNameUrl)) {
    // タグページ: /tag/{tagName}
    $baseRoute = "/tag/" . htmlspecialchars($tagNameUrl);
} elseif (!empty($actorNameUrl)) {
    // アクターページ: /actor/{actorName}
    $baseRoute = "/actor/" . htmlspecialchars($actorNameUrl);
} elseif (!empty($manufacturerNameUrl)) {
    // メーカーページ: /manufacturer/{manufacturerName}
    $baseRoute = "/manufacturer/" . htmlspecialchars($manufacturerNameUrl);
} elseif (!empty($seriesNameUrl)) {
    // シリーズページ: /series/{seriesName}
    $baseRoute = "/series/" . htmlspecialchars($seriesNameUrl);
} else {
    // ホームページまたはその他のページ
    $baseRoute = "";
}

// サイトIDのプレフィックスを決定（'all' や空の場合はプレフィックスなし）
// SiteIDが 'all' の場合や、ルート(/)の場合、URLにはサイトIDを含めない
$sitePrefix = ($siteId === 'all' || empty($siteId) || $baseRoute === "") ? '' : "/" . htmlspecialchars($siteId);
$baseLink = $sitePrefix . $baseRoute;

// 現在のページと総ページ数の必須チェック
$currentPage = $currentPage ?? 1;
$totalPages = $totalPages ?? 1;

if ($totalPages <= 1) {
    return;
}

// ページネーションに表示するページ数の範囲を決定 (例: 現在のページから前後2ページ)
$startPage = max(1, $currentPage - 2);
$endPage = min($totalPages, $currentPage + 2);

if ($startPage > 1) {
    $startPage = max(1, $startPage - 1);
}
if ($endPage < $totalPages) {
    $endPage = min($totalPages, $endPage + 1);
}
?>

<nav aria-label="Page navigation">
    <ul class="pagination justify-content-center mt-3">
        
        <li class="page-item <?= $currentPage === 1 ? 'disabled' : '' ?>">
            <a class="page-link" href="<?= htmlspecialchars($baseLink) ?>?page=1" aria-label="First">
                <span aria-hidden="true">&laquo;</span>
            </a>
        </li>
        
        <li class="page-item <?= $currentPage === 1 ? 'disabled' : '' ?>">
            <a class="page-link" href="<?= htmlspecialchars($baseLink) ?>?page=<?= max(1, $currentPage - 1) ?>" aria-label="Previous">
                <span aria-hidden="true">&lt;</span>
            </a>
        </li>
        
        <?php if ($startPage > 1): ?>
            <li class="page-item disabled"><span class="page-link">...</span></li>
        <?php endif; ?>

        <?php for ($i = $startPage; $i <= $endPage; $i++): ?>
            <li class="page-item <?= $i === $currentPage ? 'active' : '' ?>">
                <a class="page-link" href="<?= htmlspecialchars($baseLink) ?>?page=<?= $i ?>">
                    <?= $i ?>
                </a>
            </li>
        <?php endfor; ?>
        
        <?php if ($endPage < $totalPages): ?>
            <li class="page-item disabled"><span class="page-link">...</span></li>
        <?php endif; ?>

        <li class="page-item <?= $currentPage === $totalPages ? 'disabled' : '' ?>">
            <a class="page-link" href="<?= htmlspecialchars($baseLink) ?>?page=<?= min($totalPages, $currentPage + 1) ?>" aria-label="Next">
                <span aria-hidden="true">&gt;</span>
            </a>
        </li>

        <li class="page-item <?= $currentPage === $totalPages ? 'disabled' : '' ?>">
            <a class="page-link" href="<?= htmlspecialchars($baseLink) ?>?page=<?= $totalPages ?>" aria-label="Last">
                <span aria-hidden="true">&raquo;</span>
            </a>
        </li>

    </ul>
</nav>

--- FILE: ./views/components/_work_card.php ---

<?php
/**
 * 単一の作品カードコンポーネント
 * @var array $work データベースから取得した単一の作品データ
 * @var string $tagName 親ビューから渡される現在のタグ名 (今回追加)
 */

// このコンポーネントは、親ビューで $work 変数がセットされていることを前提とする
if (!isset($work) || !is_array($work)) {
    return;
}

// サイトIDを取得（worksテーブルのsite_idカラムを想定）
$siteId = $work['site_id'] ?? 'default';

// ★修正1: siteIdが'all'の場合、URLに /all を含めないためのプレフィックスを定義
// カテゴリ別リンク (manufacturer/actor) 用
$pathPrefix = ($siteId === 'all') ? '' : "/" . htmlspecialchars($siteId);

// ★追加: 親ビューからタグ名が渡されていない場合は空文字を設定 (安全対策)
$tagName = $tagName ?? ''; 
?>

<div class="col">
    <div class="card bg-dark border-secondary h-100 work-card">
        
        <a href="/work/<?= htmlspecialchars($work['work_id']) ?>" title="<?= htmlspecialchars($work['title'] ?? '') ?>">
            <img src="<?= htmlspecialchars($work['cover_url'] ?? '') ?>" class="card-img-top" alt="<?= htmlspecialchars($work['title'] ?? '') ?>" loading="lazy">
        </a>
        
        <div class="card-body p-2">
            <p class="card-text text-muted small mb-1">ID: <?= htmlspecialchars($work['work_id'] ?? 'N/A') ?></p>
            
            <h5 class="card-title work-title-link mb-2">
                <a href="/work/<?= htmlspecialchars($work['work_id'] ?? '') ?>" class="text-white" title="<?= htmlspecialchars($work['title'] ?? '') ?>">
                    <?= htmlspecialchars(mb_strimwidth($work['title'] ?? '', 0, 50, '...', 'UTF-8')) ?>
                </a>
            </h5>
            
            <p class="text-info small mt-1 mb-0">
                <?php 
                $brandName = $work['brand_name'] ?? null;
                if ($brandName) {
                    $urlEncodedBrandName = urlencode($brandName);
                    // ★修正2: $pathPrefixを使用してブランドリンクを生成 (e.g., /lemon/manufacturer/xxx または /manufacturer/xxx)
                    $brandLink = "{$pathPrefix}/manufacturer/{$urlEncodedBrandName}";

                    echo '<a href="' . htmlspecialchars($brandLink) . '" class="text-info" title="' . htmlspecialchars($brandName) . '">';
                    echo htmlspecialchars($brandName);
                    echo '</a>';
                } else {
                    echo "不明";
                }
                ?>
            </p>
            
            <p class="text-muted small mb-0">
                <?php
                if ($siteId !== 'default') {
                    $siteNameDisplay = strtoupper($siteId); 
                    // サイトホームへのリンク (siteId='all'の場合は /、それ以外は /{siteId})
                    $siteHomeLink = ($siteId === 'all') ? '/' : '/' . htmlspecialchars($siteId);

                    echo 'サイト: ';
                    echo '<a href="' . htmlspecialchars($siteHomeLink) . '" class="text-muted" title="' . htmlspecialchars($siteNameDisplay) . 'の作品一覧">';
                    echo htmlspecialchars($siteNameDisplay);
                    echo '</a>';
                }
                ?>
            </p>

            <p class="text-danger small mb-0 actor-names">
                <?php 
                $actorNamesString = $work['actor_names'] ?? '';

                if (!empty($actorNamesString)) {
                    $actorNames = array_map('trim', explode(',', $actorNamesString));
                    $links = [];
                    
                    foreach ($actorNames as $name) {
                        if (empty($name)) continue;

                        $urlEncodedName = urlencode($name);
                        // ★修正3: $pathPrefixを使用して俳優リンクを生成 (e.g., /lemon/actor/xxx または /actor/xxx)
                        $actorLink = "{$pathPrefix}/actor/{$urlEncodedName}";
                        
                        $links[] = '<a href="' . htmlspecialchars($actorLink) . '" class="text-danger" title="' . htmlspecialchars($name) . '">' . htmlspecialchars($name) . '</a>';
                    }
                    
                    echo implode(', ', $links);
                } else {
                    echo '不明'; 
                }
                ?>
            </p>
            <p class="text-info small mt-1 mb-0">
                <?php 
                $releaseDate = $work['release_date'] ?? null;
                if ($releaseDate) {
                    echo htmlspecialchars(date('Y/m/d', strtotime($releaseDate)));
                } else {
                    echo "日付不明";
                }
                ?>
            </p>
        </div>
        
        <div class="card-footer bg-secondary p-0 border-0">
            <?= $work['link_title'] ?? '' ?>
        </div>
        
        <?php if (!empty($tagName)): ?>
        <div class="card-footer bg-dark p-2 border-top border-secondary">
            <p class="text-white small mb-0">
                <i class="fas fa-tag me-1"></i> <?= htmlspecialchars($tagName) ?>
            </p>
        </div>
        <?php endif; ?>
        
    </div>
</div>

--- FILE: ./views/tag/index.php ---

<div class="row row-cols-2 row-cols-sm-3 row-cols-md-4 row-cols-lg-5 g-3">
    <?php 
    // $works配列が存在し、空ではない場合にループを実行
    if (!empty($works)): 
    ?>
        <?php foreach ($works as $work): ?>
            <?php require __DIR__ . '/../components/_work_card.php'; ?>
        <?php endforeach; ?>
    <?php else: ?>
        <div class="col-12">
            <p class="alert alert-warning">該当する作品は見つかりませんでした。</p>
        </div>
    <?php endif; ?>
</div>

<?php
// タグ別ページであることを示す変数を設定
$isTagPage = true; 

// TagControllerから渡されたページネーションに必要な変数:
// $currentPage, $totalPages, $siteId, $tagNameUrl, $pagination 

// ページネーションコンポーネントを読み込む
require __DIR__ . '/../components/_pagination.php';
?>

--- FILE: ./views/series/index.php ---

<div class="row row-cols-2 row-cols-sm-3 row-cols-md-4 row-cols-lg-5 g-3">
    <?php 
    // $works配列が存在し、空ではない場合にループを実行
    if (!empty($works)): 
    ?>
        <?php foreach ($works as $work): ?>
            <?php require __DIR__ . '/../components/_work_card.php'; ?>
        <?php endforeach; ?>
    <?php else: ?>
        <div class="col-12">
            <p class="alert alert-warning">該当する作品は見つかりませんでした。</p>
        </div>
    <?php endif; ?>
</div>

<?php
// タグ別ページであることを示す変数を設定
$isTagPage = true; 

// TagControllerから渡されたページネーションに必要な変数:
// $currentPage, $totalPages, $siteId, $tagNameUrl, $pagination 

// ページネーションコンポーネントを読み込む
require __DIR__ . '/../components/_pagination.php';
?>

--- FILE: ./views/actor/index.php ---

<div class="row row-cols-2 row-cols-sm-3 row-cols-md-4 row-cols-lg-5 g-3">
    <?php 

    // dd($works);
    // $works配列が存在し、空ではない場合にループを実行
    if (!empty($works)): 
    ?>
        <?php foreach ($works as $work): ?>
            <?php require __DIR__ . '/../components/_work_card.php'; ?>
        <?php endforeach; ?>
    <?php else: ?>
        <div class="col-12">
            <p class="alert alert-warning">該当する作品は見つかりませんでした。</p>
        </div>
    <?php endif; ?>
</div>

<?php
// ★ 修正点: 以下の手動設定行を削除しました ★
// $isTagPage = true; 

// ページネーションコンポーネントを読み込む
// Controllerから渡された $currentPage, $totalPages, $siteId,
// および $isTagPage/$tagNameUrl または $isSeriesPage/$seriesNameUrl または $isActorPage/$actorNameUrl が利用されます。
require __DIR__ . '/../components/_pagination.php';
?>

--- FILE: ./assets/css/styles.css ---

/*
 * ファイル名: styles.css (最終調整版)
 * 場所: public_html/assets/css/
 */

/* -------------------------------------------
 * 全体的なリセットとダークテーマの適用
 * ------------------------------------------- */
body { 
    font-family: sans-serif; 
    margin: 0;
    background-color: #111 !important; /* 背景を黒く強調 */
    color: #ddd; /* 明るい文字色 */
}

/* Bootstrapの標準スタイルを上書きして完全にダーク化 */
.bg-dark, .navbar-dark, footer.bg-dark {
    background-color: #000 !important;
}

/* アクセントカラー */
.text-emphasis {
    color: #ff3333 !important; /* 強制的に赤を適用 */
}

/* リンクの基本色 */
a {
    color: #ccc;
    text-decoration: none;
}
a:hover {
    color: #ff3333; /* ホバーで赤に */
}
/* Bootstrapの.nav-linkも上書き */
.nav-link {
    color: #ccc !important;
}
.nav-link:hover {
    color: #ff3333 !important;
}

/* -------------------------------------------
 * レイアウト要素 (コントラスト強化)
 * ------------------------------------------- */

/* 【重要修正】フッターとヘッダーの間にあるメインコンテナの背景色を統一 */
.container {
    background-color: #111 !important;
    padding-top: 20px;
}

/* 【重要修正】パンくずリストの背景色を黒に */
.breadcrumb {
    background-color: #1a1a1a !important; 
    border: 1px solid #333;
}
.breadcrumb-item a {
    color: #ddd !important;
}
.breadcrumb-item.active {
    color: #ff3333 !important; /* 現在地を赤で強調 */
}

.sidebar {
    background-color: #222 !important;
    padding: 15px;
    border-radius: .25rem;
    border: 1px solid #333;
    color: #ddd;
}

.main-content-card {
    background-color: #222 !important;
    padding: 20px;
    border-radius: .5rem;
    color: #ddd;
}

/* -------------------------------------------
 * ナビゲーション コンパクトスタイル
 * ------------------------------------------- */
.navbar-compact .navbar-brand, 
.navbar-compact .navbar-text, 
.navbar-compact .btn, 
.navbar-compact .form-control {
    padding-top: 0.1rem !important;
    padding-bottom: 0.1rem !important;
    font-size: 0.8rem;
    line-height: 1.2;
    height: auto !important;
}

.navbar-compact.navbar {
    padding-top: 0.3rem; 
    padding-bottom: 0.3rem;
    align-items: center;
}

.login-form-compact .form-control-sm {
    width: 100px;
}

.login-form-compact {
    flex-wrap: nowrap;
    margin-left: 10px;
}

/* ===============================================
 * フッター領域の視認性改善
 * =============================================== */

/* フッターコンテナ全体 */
footer {
    /* 現在の背景色 #111 よりも少し明るい背景色を設定し、浮き上がらせる */
    background-color: #1a1a1a !important; 
    
    /* 上部に細い区切り線を入れ、メインコンテンツとフッターを明確に分ける */
    border-top: 2px solid #333 !important; 
    
    /* 上下のパディングを増やし、領域を確保 */
    padding-top: 30px !important;
    padding-bottom: 30px !important;
    
    /* テキスト全体を明るい色にする */
    color: #cccccc !important;
    font-size: 0.9rem;
}

/* 著作権表示（Copyright）部分 */
.copyright-text {
    color: #999999 !important; /* 著作権表示は少し暗いトーンで */
    font-size: 0.8rem;
    margin-top: 15px; /* 上部に余白を追加 */
}

/* フッター内のリンク */
footer a {
    color: #ffcccc !important; /* リンクを明るい赤/ピンク系にして目立たせる */
    text-decoration: none; /* 下線をなくし、モダンに */
    transition: color 0.2s;
}

footer a:hover {
    color: #ff3333 !important; /* ホバー時に強い赤で強調 */
    text-decoration: underline; /* ホバー時のみ下線を表示 */
}

/* フッターの各セクションのタイトル */
.footer-title {
    color: #ffffff !important; /* タイトルを純粋な白にして強調 */
    font-weight: bold;
    margin-bottom: 10px;
    border-bottom: 1px solid #333; /* タイトルの下に細い線 */
    padding-bottom: 5px;
}

/* style.css (例) */

.work-card .card-footer a {
    /* リンク全体をブロック要素にしてフッター全体に広げる */
    display: block; 
    /* 左右のパディングでリンクのクリック領域を確保 */
    padding: 0.5rem; 
    /* 背景色とテキスト色の調整 */
    background-color: #343a40; /* bg-secondary と同等 */
    color: #fff; /* テキストを白色に */
    text-align: center;
    
    /* リンクテキストが長すぎる場合の処理 */
    white-space: nowrap; /* テキストを折り返さない */
    overflow: hidden; /* はみ出した部分を隠す */
    text-overflow: ellipsis; /* ... で省略記号を表示 */
}

.work-card .card-footer a:hover {
    background-color: #495057; /* ホバー時の色変更 */
    text-decoration: none;
}

--- FILE: ./cli.php ---

<?php
// コマンドラインからの実行以外は拒否
if (PHP_SAPI !== 'cli') {
    die("Access denied. This script can only be run from the command line.\n");
}

// 絶対パスの基点を定義 (public_html ディレクトリ)
$baseDir = __DIR__;

// ------------------------------------
// 0. 環境設定とオートロード
// ------------------------------------
require $baseDir . '/vendor/autoload.php';

// ★★★ 修正箇所：すべての依存関係を手動で読み込む ★★★
require_once $baseDir . '/app/Core/Database.php';
require_once $baseDir . '/app/Controllers/DataController.php';

// ★★★ WorksModel.php の読み込みを追加 ★★★
require_once $baseDir . '/app/Models/WorksModel.php';
// ★★★ --------------------------------------- ★★★

// エラー報告を最大化
ini_set('display_errors', 1);
error_reporting(E_ALL);

// 無制限の実行時間とメモリ設定 (CLI処理向け)
set_time_limit(0);
ini_set('memory_limit', '1G');

// ------------------------------------
// 1. 初期設定とコアファイルの読み込み
// ------------------------------------
global $config;
$config = require_once $baseDir . '/config.php';

// ★★★ use 宣言 ★★★
use App\Core\Database;
use App\Models\WorksModel; // WorksModel も使用するため追加
// ★★★ ----------- ★★★

// データベース接続クラスの準備
Database::loadConfig($config);

// ------------------------------------
// 2. コマンドライン引数の解析
// ------------------------------------
$command = $argv[1] ?? 'help';
// 変更: 'import' 後の引数 (CSVファイルパスのみ) が $args[0] に入る
$args = array_slice($argv, 2);

// ------------------------------------
// 3. コマンドの実行
// ------------------------------------
try {
    switch ($command) {
        case 'import':
            // 変更: 引数の検証 (CSVファイルパスが最低1つ必要)
            if (count($args) < 1) {
                echo "Usage: php cli.php import [csv_file_path]\n"; // helpメッセージを修正
                exit(1);
            }
            // 変更: csvFilePath のみを取得
            $csvFilePath = $args[0];

            $controllerClass = 'App\\Controllers\\DataController';

            if (class_exists($controllerClass)) {

                // ★★★ 修正 1：WorksModel をインスタンス化する ★★★
                $worksModel = new WorksModel();

                // ★★★ 修正 2：コントローラに WorksModel を引数として渡す ★★★
                $controller = new $controllerClass($worksModel);

                // ★★★ 修正 3：正しいメソッド名 (importData) を呼び出す ★★★
                if (method_exists($controller, 'importData')) {
                    // 変更: DataController側の引数に合わせて $csvFilePath のみ渡す
                    $controller->importData($csvFilePath);
                } else {
                    // ここでエラーが出た場合は、DataController.phpのメソッド名を確認
                    echo "Fatal Error: Method 'importData' not found in DataController.\n";
                }
            } else {
                 // ここでエラーが出たら、DataController.phpのファイル名や名前空間を確認
                 echo "Fatal Error: Class 'App\\Controllers\\DataController' not found. Check file path or namespace.\n";
            }
            break;

        case 'help':
        default:
            echo "Usage: php cli.php [command] [arguments]\n";
            echo "Commands:\n";
            // 変更: helpメッセージを修正
            echo " import [csv_file_path] - Imports data (e.g., ./data/okashi.csv).\n";
            break;
    }
} catch (\Exception $e) {
    echo "Fatal Error: " . $e->getMessage() . "\n";
    exit(1);
}

exit(0);